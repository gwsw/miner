<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Asteroid Miner</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>
<script>

/** TODO
* Menu
> Port menu
> Allow move left (add stuff to beginning of array)
> View follow y height of ship.
> Direction arrows.
**/

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    button_border          : 3,
    crash_vel2             : .04,
    crit_fuel              : 2,
    deposit_dig_max_dist   : 10,
    deposit_screens_per    : 1,
    fuel_per_thrust        : .04,
    gauge_border           : 3,
    gravity                : 0.002,
    liftoff_fuel           : 1,
    liftoff_vel            : 0.02,
    low_fuel               : 10,
    max_fuel               : 100,
    menu_border            : 4,
    min_elev               : 10,
    ore_mass_max           : 1000,
    ore_mass_min           : 8,
    port_screens_per       : 5,
    port_land_max_dist     : 10,
    ship_bot_thrust        : 0.004,
    ship_mass              : 50,
    ship_max_cargo         : 200,
    ship_side_thrust       : 0.01,
    terr_base              : 24, // pixels
    terr_step              : 22, // pixels
    view_width_m           : 1500,
    view_xstep_m           : 50,
    ///world_diam             : 1000*1000, // 1000 km

    color_btn_active       : "10ff40",
    color_btn_active_fg    : "000000",
    color_btn_dir          : "1050c0",
    color_btn_dir_fg       : "000000",
    color_btn_inactive     : "c08010",
    color_btn_inactive_fg  : "000000",
    color_btn_none         : "a0a0a0",
    color_btn_none_fg      : "383838",
    color_dash_bg          : "669ae4",
    color_fuel             : "10d040",
    color_gauge_bg         : "e0e0e0",
    color_gauge_border     : "a098b0",
    color_gauge_crit       : "ff1010",
    color_gauge_low        : "a06000",
    color_gauge_text       : "000000",
    color_gauge_title      : "000000",
    color_msg_bg           : "c0c0c0",
    color_msg_fg           : "000000",
    color_msg_border       : "ff0000",
    color_menu_bg          : "40ffff",
    color_menu_fg          : "000000",
    color_menu_border      : "000000",
    color_menu_btn_bg      : "2050c0",
    color_menu_btn_fg      : "ffffff",
    color_menu_btn_held    : "ffff00",
    color_menu_hdr_fg      : "000000",
    color_ore              : "d4af37",
    color_port             : "f0f0f0",
    color_resmap_bg        : "a8a818",
    color_ship             : "10ffff",
    color_sky              : "000000",
    color_status_bg        : "d0d050",
    color_status_fg        : "000000",
    color_terrain          : "707070",
    color_thrust           : "ff3010",
};

// --------------------------------------------------------------------
class Color {
    constructor(hex) {
        this.hex_str = hex;
    }
    hex() {
        return this.hex_str;
    }
    jstring() {
        return "#" + this.hex_str;
    }
    get_comp(comp) {
        return parseInt(this.hex_str.substr(comp*2, 2), 16);
    }
    darker(mult) {
        return new Color(hex2(this.get_comp(0)*mult) + hex2(this.get_comp(1)*mult) + hex2(this.get_comp(2)*mult));
    }
    opposite() {
        return new Color(hex2(255-this.get_comp(0)) + hex2(255-this.get_comp(1)) + hex2(255-this.get_comp(2)));
    }
    contrast() {
        const bright = this.get_comp(0) + this.get_comp(1) + this.get_comp(2);
        return new Color((bright > (3*128)) ? "000000" : "ffffff");
    }
};

// --------------------------------------------------------------------
class Vector {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
    }
    mul(num) {
        return new Vector(this.x*num, this.y*num);
    }
    norm2() {
        return this.x*this.x + this.y*this.y;
    }
}; // class Vector

// --------------------------------------------------------------------
class Graphics {
    constructor(ctx) {
        this.ctx = ctx;
        const text_size = ctx.measureText("M");
        this.font_height = Math.floor(text_size.width * 1.2); // FIXME
    }
    clear(color) {
        const canvas = this.ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;
        this.ctx.clearRect(0, 0, w, h);
        this.draw_rect(0, 0, w, h, color);
    }
    draw_rect(x, y, w, h, color) {
        if (color != undefined && color != null) this.ctx.fillStyle = color.jstring();
        this.ctx.fillRect(x, y, w, h);
    }
    draw_centered_rect(cx, cy, w, h, color) {
        this.draw_rect(cx - w/2, cy - h/2, w, h, color);
    }
    draw_outline(x, y, w, h, xb, yb, color) {
        this.draw_rect(x,      y,       w-xb,   yb,   color);
        this.draw_rect(x+w-xb, y,       xb,     h-yb, color);
        this.draw_rect(x+xb,   y+h-yb,  w-xb,   yb,   color);
        this.draw_rect(x,      y+yb,    xb,     h-yb, color);
    }
    draw_centered_outline(cx, cy, w, h, xb, yb, color) {
        this.draw_outline(cx - w/2, cy - h/2, w, h, xb, yb, color);
    }
    draw_outlined_rect(x, y, w, h, xb, yb, bg_color, border_color) {
        this.draw_rect(x+xb, y+yb, w-2*xb, h-2*yb, bg_color);
        this.draw_outline(x, y, w, h, xb, yb, border_color);
    }
    draw_circle(x, y, r, color) {
        this.ctx.beginPath();
        this.ctx.fillStyle = color.jstring();
        this.ctx.arc(x, y, r, 0, 2*Math.PI);
        this.ctx.fill();
    }
    draw_text(x, y, text, color) {
        this.ctx.fillStyle = color.jstring();
        this.ctx.fillText(text, x, y+this.font_height);
    }
    measure_text(text) {
        const text_size = this.ctx.measureText(text);
        return { width: text_size.width, height: this.font_height };
    }
    draw_centered_text(x, y, w, text, color) {
        const text_size = this.measure_text(text);
        const nx = x + (w - text_size.width) / 2;
        if (nx > x) x = nx;
        this.draw_text(x, y, text, color);
        return text_size;
    }
}; // class Graphics

// --------------------------------------------------------------------
class Drawable {
    constructor(x, y, w, h) {
        this.move(x, y, w, h);
    }
    move(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
}; // class Drawable

// --------------------------------------------------------------------
class DashClock {
    constructor() {
    }
}; // class DashClock

// --------------------------------------------------------------------
class Gauge extends Drawable {
    constructor(x, y, w, h, title, color, max_value, low_value = -1, crit_value = -1, fetcher = null) {
        super(x, y, w, h);
        this.title = title;
        this.color = color;
        this.max_value = max_value;
        this.low_value = low_value;
        this.crit_value = crit_value;
        this.fetcher = fetcher;
        this.value = 0;
    }
    set_value(value) {
        if (value < 0) value = 0;
        if (value > this.max_value) value = this.max_value;
        this.value = value;
    }
    get_value(value) {
        return this.value;
    }
    draw(gfx) {
        if (this.fetcher != null)
            this.set_value(this.fetcher.gauge_value());
        let title_size = gfx.draw_centered_text(this.x, this.y, this.w, this.title, config.color_gauge_title);
        const gh = this.h - title_size.height *1.5;
        const gb = config.gauge_border;
        const inh = gh - 2*gb;
        const inw = this.w - 2*gb;
        const barh = inh * this.value / this.max_value;
        const bot = this.y + this.h;
        const value_text = Math.floor(this.value).toString();
        const value_text_size = gfx.measure_text(value_text);
        gfx.draw_outlined_rect(this.x, bot-gh, this.w, gh, gb, gb, config.color_gauge_bg, config.color_sky);
        gfx.draw_rect(this.x+gb, bot-gb-barh, inw, barh, this.color);
        gfx.draw_centered_text(this.x, bot-value_text_size.height*1.5, this.w, value_text, config.color_gauge_text);
        let ctext = null;
        let ccolor = null;
        if (this.value <= this.crit_value) {
            ctext = "DANGER"; ccolor = config.color_gauge_crit;
        } else if (this.value <= this.low_value) {
            ctext = "LOW"; ccolor = config.color_gauge_low;
        } else if (this.value >= this.max_value) {
            ctext = "MAX"; ccolor = config.color_gauge_text;
        }
        if (ctext != null)
            gfx.draw_centered_text(this.x, this.y+this.h/2-value_text_size.height/2, this.w, ctext, ccolor);
    }
}; // class Gauge

// --------------------------------------------------------------------
class FuelGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Fuel", config.color_fuel, config.max_fuel, config.low_fuel, config.crit_fuel, new ShipFuelFetcher(ship));
    }
}; // class FuelGauge

// --------------------------------------------------------------------
class OreGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Cargo", config.color_ore, ship.max_cargo, -1, -1, new ShipCargoFetcher(ship));
    }
}; // class OreGauge

// --------------------------------------------------------------------
class AltitudeGauge extends Gauge {
    constructor(x, y, w, h, ship, terrain) {
        super(x, y, w, h, "Alt.", config.color_terrain, terrain.max_elev, -1, -1, new ShipAltitudeFetcher(ship, terrain));
    }
}; // class AltitudeGauge

// --------------------------------------------------------------------
class Button extends Drawable {
    constructor(state_titles, state_colors, state_colors_fg, state, x, y, w, h, holdable = false, state_fetcher = null) {
        super(x, y, w, h);
        this.state_titles = state_titles;
        this.state_colors = state_colors;
        this.state_colors_fg = state_colors_fg;
        this.state = state;
        this.state_fetcher = state_fetcher;
        this.holdable = holdable;
    }
    set_state(state) {
        this.state = state;
    }
    inside(x, y) {
        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
    }
    keystroke(code, down) {
    }
    click(down) {
    }
    draw(gfx, held) {
        if (this.state_fetcher != null)
            this.state = this.state_fetcher.button_state();
        let bb = config.button_border;
        const color = held ? config.color_menu_btn_held : this.state_colors[this.state];
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, bb, bb, color, config.color_sky);
        //let cy = this.y + this.h/2; // FIXME
        let cy = this.y + (this.h - gfx.font_height) / 2;
        gfx.draw_centered_text(this.x, cy, this.w, this.state_titles[this.state], this.state_colors_fg[this.state]);
    }
}; // class Button

// --------------------------------------------------------------------
class Form extends Drawable {
    constructor(x, y, w, h, bg) {
        super(x, y, w, h);
        this.bg = bg;
        this.btns = [];
        this.held_btn = null;
    }
    add(btn) {
        this.btns.push(btn);
    }
    mouse(down, x, y) {
        for (const btn of this.btns) {
            if (btn.holdable && btn.inside(x, y)) {
                this.held_btn = down ? btn : null;
                btn.click(down);
                return;
            }
        }
        if (!down) this.held_btn = null;
    }
    draw(gfx) {
        gfx.draw_rect(this.x, this.y, this.w, this.h, this.bg);
        for (const btn of this.btns) {
            btn.draw(gfx, btn == this.held_btn);
        }
    }
}; // class Form

// --------------------------------------------------------------------
class MenuButton extends Button {
    constructor(menu, title, slot) {
        super([title], [config.color_menu_btn_bg], [config.color_menu_btn_fg],
            0, menu.btn_x, menu.btn_y + slot * (menu.btn_h + menu.btn_sp), menu.btn_w, menu.btn_h, true);
        this.slot = slot;
    }
    click(down) {
        super.click(down);
        if (!down) return;
        this.click_menu_button(this.slot);
    }
}; // class MenuButton

// --------------------------------------------------------------------
class TextMenuButton extends MenuButton {
    constructor(menu, title, value, slot) {
        super(menu, title, slot);
        this.value = value;
    }
    click_menu_button(slot) {
    }
}; // class TextMenuButton

// --------------------------------------------------------------------
class YesSellMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "Yes", slot);
        this.ship = menu.ship;
        this.price = menu.price;
    }
    click_menu_button(slot) {
        const cargo = this.ship.unload_ore();
        _game.user_acct.add_cash(this.price * cargo, "Sale of "+cargo.toString()+" tons ore");
        _game.pop_form();
    }
}; // class YessSellMenuButton

// --------------------------------------------------------------------
class NoSellMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "No", slot);
    }
    click_menu_button(slot) {
        _game.pop_form();
    }
}; // class YessSellMenuButton

// --------------------------------------------------------------------
class Menu extends Form {
    constructor(x, y, w, h, desc) {
        super(x, y, w, h, config.color_menu_bg);
        this.desc = desc;
        //FIXME
        const desc_h = 40; ///FIXME
        this.btn_w = Math.floor(w * 0.6);
        this.btn_h = Math.floor(h / 10);
        this.btn_sp = Math.floor(this.btn_h * .3);
        this.btn_x = x + (w - this.btn_w) / 2;
        this.btn_y = y + desc_h + this.btn_h * .75;
    }
    draw(gfx) {
        super.draw(gfx);
        gfx.draw_text(this.x +20, this.y + this.btn_h*.5, this.desc, config.color_menu_hdr_fg); // FIXME
        gfx.draw_outline(this.x, this.y, this.w, this.h, config.menu_border, config.menu_border, config.color_menu_border);
    }
}; // class Menu

// --------------------------------------------------------------------
class SellMenu extends Menu {
    constructor(x, y, w, h, ship, price) {
        super(x, y, w, h, "");
        this.ship = ship;
        this.price = price;
    }
    init() {
        const amt = this.ship.cargo;
        this.desc = "Do you want to sell the "+amt.toString()+" tons of cargo in your ship?";
        this.add(new YesSellMenuButton(this, 0));
        this.add(new NoSellMenuButton(this, 1));
        return this;
    }
}; // class SellMenu

// --------------------------------------------------------------------
class SellButton extends MenuButton {
    constructor(menu, price) {
        super(menu, "Sell ore at $"+price.toString()+" per ton", 0);
        this.price = price;
    }
    click_menu_button(slot) {
        if (_game == null) return;
        _game.need_sell = this.price;
    }
}; // class SellButton

// --------------------------------------------------------------------
class BuyFuelButton extends MenuButton {
    constructor(menu, price) {
        super(menu, "Buy fuel at $"+price.toString()+" per liter", 1);
    }
    click_menu_button(slot) {
        ///FIXME
    }
}; // class BuyFuelButton

// --------------------------------------------------------------------
class BorrowButton extends MenuButton {
    constructor(menu) {
        super(menu, "Borrow money", 2);
    }
    click_menu_button(slot) {
        ///FIXME
    }
}; // class BorrowButton

// --------------------------------------------------------------------
class EStoreButton extends MenuButton {
    constructor(menu) {
        super(menu, "Equipment store", 3);
    }
    click_menu_button(slot) {
        ///FIXME
    }
}; // class EStoreButton

// --------------------------------------------------------------------
class LeavePortButton extends MenuButton {
    constructor(menu) {
        super(menu, "Leave this port", 4);
    }
    click_menu_button(slot) {
        if (_game == null) return;
        _game.exit_port();
        _game.pop_form();
        _game.set_status("Ready for liftoff.");
    }
}; // class LeavePortButton

// --------------------------------------------------------------------
class PortMenu extends Menu {
    constructor(x, y, w, h, port) {
        super(x, y, w, h, "Welcome to port "+port.name+"!");
        this.port = port;
    }
    init() {
        this.add(new SellButton(this, this.port.sell_ore_price()));
        this.add(new BuyFuelButton(this, this.port.buy_fuel_price()));
        this.add(new BorrowButton(this));
        this.add(new EStoreButton(this));
        this.add(new LeavePortButton(this));
        return this;
    }
}; // class PortMenu

// --------------------------------------------------------------------
class Store {
constructor() {
}
}; // class Store

// --------------------------------------------------------------------
class StoreMenu {
    constructor() {
    }
}; // class StoreMenu

// --------------------------------------------------------------------
class ScoopButton extends Button {
    constructor(x, y, w, h) {
        super(["Ore scoop: off", "Ore scoop: on", "Ore scoop: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg],
            2, x, y, w, h);
        this.holdable = (this.state != 2);
    }
    click(down) {
        if (!down) return;
    }
}; // class ScoopButton

// --------------------------------------------------------------------
class LSIButton extends Button {
    constructor(x, y, w, h) {
        super(["LSI: off", "LSI: on"],
            [config.color_btn_inactive, config.color_btn_active],
            [config.color_btn_inactive_fg, config.color_btn_active_fg],
            0, x, y, w, h);
        this.holdable = true;
    }
    click(down) {
        if (!down) return;
        this.set_state((this.state == 0) ? 1 : 0);
    }
}; // class LSIButton

// --------------------------------------------------------------------
class FlyingButton extends Button {
    constructor(x, y, w, h, ship) {
        super(["On ground", "Flying"],
            [config.color_btn_inactive, config.color_btn_active],
            [config.color_btn_inactive_fg, config.color_btn_active_fg],
            0, x, y, w, h, false, new ShipFlyingStateFetcher(ship));
    }
}; // class LSIButton

// --------------------------------------------------------------------
class OreDetectorButton extends Button {
    constructor(x, y, w, h) {
        super(["Ore detector: off", "Ore detector: on", "Ore detector: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg],
            2, x, y, w, h);
        this.holdable = (this.state != 2);
    }
    static click(down) {
        if (!down) return;
    }
}; // class OreDetectorButton

// --------------------------------------------------------------------
class PortMapButton extends Button {
    constructor(x, y, w, h) {
        super(["Port map: off", "Port map: on", "Port map: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg],
            2, x, y, w, h);
        this.holdable = (this.state != 2);
    }
    static click(down) {
        if (!down) return;
    }
}; // class PortMapButton

// --------------------------------------------------------------------
class LiveStatusButton extends Button {
    constructor(x, y, w, h) {
        super(["Status"], [config.color_btn_none], [config.color_btn_none_fg], 
            0, x, y, w, h);
    }
}; // class LiveStatusButton

// --------------------------------------------------------------------
class SouthButton extends Button {
    constructor(x, y, w, h) {
        super(["UP"], [config.color_btn_dir], [config.color_btn_dir_fg],
            0, x, y, w, h);
    }
    click(down) {
        if (_game != null) _game.keystroke("ArrowDown", down);
    }
}; // class SouthButton

// --------------------------------------------------------------------
class ResourceMap extends Drawable {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.installed = false;
        this.active = false;
    }
    install(ship) {
        this.installed = true;
    }
    activate(active) {
        this.active = active;
    }
    draw(gfx) {
        const color = this.active ? config.color_resmap_bg : this.installed ? config.color_btn_inactive : config.color_btn_none;
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, config.gauge_border, config.gauge_border, color, config.color_sky); 
    }
}; // class ResourceMap

// --------------------------------------------------------------------
class OreDetector extends ResourceMap {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
}; // class OreDetector

// --------------------------------------------------------------------
class PortMap extends ResourceMap {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
}; // class PortMap

// --------------------------------------------------------------------
class LiveStatus extends Drawable {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.message = "Welcome.";
    }
    set_status(status) {
        this.message = status;
    }
    draw(gfx) {
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, config.gauge_border, config.gauge_border, config.color_status_bg, config.color_sky); 
        gfx.draw_text(this.x + config.gauge_border *2.0, this.y + config.gauge_border *2.5, this.message, config.color_status_fg);
    }
}; // class LiveStatus

// --------------------------------------------------------------------
class Terrain extends Drawable {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.max_elev = h-20; // FIXME
        this.peaks = [];
    }
    cover(sxpos, expos) {
        //@@FIXME
        if (this.peaks.length == 0)
            this.peaks.push(config.min_elev);
        let elev = this.peaks[this.peaks.length-1];
        while (this.peaks.length * config.terr_step < expos) {
            elev += (Math.random() * config.terr_step) - (config.terr_step/2);
            if (elev < config.min_elev) elev = config.min_elev;
            if (elev > this.max_elev) elev = this.max_elev;
            this.peaks.push(elev);
        }
    }
    index(xpos) {
        return Math.floor(xpos / config.terr_step);
    }
    elevation(xpos) {
this.cover(xpos-1000, xpos+1000); // FIXME
/*<<<*/
/*<<<*/ const lo = 0;
/*<<<*/
        const pi = this.index(xpos);
        const elev1 = this.peaks[pi];
        const elev2 = this.peaks[pi+1];
        const xpos1 = pi * config.terr_step;
        const xpos2 = xpos1 + config.terr_step;
        const e = (elev2 - elev1) * (xpos - xpos1) / (xpos2 - xpos1);
        return elev1 + e;
    }
    draw(gfx, xpos) {
        if (this.peaks.length == 0) return;
        const ctx = gfx.ctx;
        ctx.beginPath();
        const bot = this.y + this.h;
        let x = this.x;
        let xs = xpos % config.terr_step;
        if (xs > 0) x -= xs;
        let xlast = x;
        ctx.moveTo(x, bot);
        let pi = this.index(xpos);
        for (let i = 0; ; ++i) {
            if (pi >= this.peaks.length) 
                break;
            const y = this.peaks[pi++];
            ctx.lineTo(x, bot - y);
            xlast = x;
            if (x >= this.w) break;
            x += config.terr_step;
        }
        ctx.lineTo(xlast, bot); // drop to baseline at right
        ctx.fillStyle = config.color_terrain.jstring();
        ctx.fill();
    }
}; // class Terrain

// --------------------------------------------------------------------
class TerrObjects extends Drawable {
    constructor(x, y, w, h, terrain, screens_per) {
        super(x, y, w, h);
        this.s_extend = 0;
        this.e_extend = 0;
        this.terrain = terrain;
        this.screens_per = screens_per;
        this.objects = [];
    }
    place(xpos, thing) {
        const mag = 10;
        const r = (randu(this.screens_per * this.w * mag));
       return (r  < mag);
    }
    index(xpos) {
        for (let i = 0; i < this.objects.length; ++i) {
            if (this.objects[i].xpos > xpos)
                return (i == 0) ? 0 : i-1;
        }
        return this.objects.length-1;
    }
    closest(xpos) {
        if (this.objects.length == 0) return null;
        let i = this.index(xpos);
        if (i < this.objects.length-1 &&
            Math.abs(this.objects[i].xpos - xpos) > Math.abs(this.objects[i+1].xpos - xpos))
            ++i;
        return this.objects[i];
    }
    draw(gfx, xpos) {
        if (this.objects.length == 0) return;
        for (let pi = this.index(xpos); pi < this.objects.length; ++pi) {
            const x = this.x + (this.objects[pi].xpos - xpos);
            if (x >= gfx.ctx.canvas.width) break;
            const y = this.y + this.h - this.terrain.elevation(this.objects[pi].xpos);
            this.objects[pi].draw(gfx, x, y);
        }
    }
}; // class TerrObjects

// --------------------------------------------------------------------
class Ports extends TerrObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.port_screens_per);
    }
    cover(sxpos, expos) {
        if (this.s_extend <= sxpos && expos <= this.e_extend) return;
        let xpos = this.e_extend;
        for (; xpos < expos; ++xpos) {
            if (this.place(xpos))
                this.objects.push(new Port(xpos));
        }
        this.e_extend = expos;
    }
    can_land(xpos) {
        const port = this.closest(xpos);
        if (port != null && Math.abs(port.xpos - xpos) <= config.port_land_max_dist)
            return port;
        return null;
    }
}; // class Ports

// --------------------------------------------------------------------
class OreDeposits extends TerrObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.deposit_screens_per);
    }
    cover(sxpos, expos) {
        if (this.s_extend <= sxpos && expos <= this.e_extend) return;
        let xpos = this.e_extend;
        for (; xpos < expos; ++xpos) {
            if (this.place(xpos))
                this.objects.push(new OreDeposit(this.ore_mass(xpos), xpos));
        }
        this.e_extend = expos;
    }
    ore_mass(xpos) {
        const M = config.ore_mass_max - config.ore_mass_min;
        const k = nhash(xpos) % M;
return config.ore_mass_min + k;
        //return config.ore_mass_min + Math.floor((k*k*k) / (M*M));
    }
}; // class OreDeposits

// --------------------------------------------------------------------
class OreDeposit {
    constructor(mass, xpos) {
        this.mass = mass;
        this.xpos = xpos;
    }
    draw(gfx, x, y) {
        if (this.mass == 0) return;
        const r = Math.sqrt(this.mass) * 1.5; // FIXME
        gfx.draw_circle(x, y, r, config.color_ore);
    }
}; // class OreDeposit

// --------------------------------------------------------------------
class Billboard {
    constructor() {
    }
}; // class Billboard

// --------------------------------------------------------------------
class Port {
    constructor(xpos) {
        this.xpos = xpos;
        this.name = "Omega Station";
    }
    draw(gfx, x, y) {
        gfx.draw_circle(x, y, config.port_land_max_dist, config.color_port);
        gfx.draw_text(x-30, y-40, this.name, config.color_port);
    }
    buy_fuel_price() {
        return 50;
    }
    sell_ore_price() {
        return 230;
    }
}; // class Port

// --------------------------------------------------------------------
class LiveView extends Drawable {
    constructor(x, y, w, h, ship, terrain, ports, deposits) {
        super(x, y, w, h);
        this.terrain = terrain;
        this.ports = ports;
        this.deposits = deposits;
        this.ship = ship;
    }
    draw(gfx) {
        const xpos = this.ship.loc.x - this.w/2;
        this.deposits.draw(gfx, xpos);
        this.ports.draw(gfx, xpos);
        this.terrain.draw(gfx, xpos);
        this.ship.draw(gfx, xpos);
    }
}; // class LiveView

// --------------------------------------------------------------------
class Account {
    constructor(deposit) {
        this.balance = deposit;
        this.logs = [];
    }
    add_cash(amt, reason) {
        this.log(amt, reason);
        this.balance += amt;
        return this.balance;
    }
    remove_cash(amt, reason) {
        this.log(-amt, reason);
        if (amt > this.balance) {
            this.log(0, "overdrawn");
            amt = this.balance;
        }
        this.balance -= amt;
        return this.balance;
    }
    log(amt, reason) {
        const time = now();
        this.logs.push(time.toString()+" "+this.balance.toString()+" + "+amt.toString()+" "+reason);
    }
}; // class Account

// --------------------------------------------------------------------
class Loan {
    constructor() {
    }
}; // class Loan

// --------------------------------------------------------------------
class MassiveObject extends Drawable {
    constructor(x, y, w, h, xpos, ypos, mass, time) {
        super(x, y, w, h);
        this.mass = mass;
        this.loc = new Vector(xpos, ypos);
        this.vel = new Vector(0,0);
        this.acc = new Vector(0,0);
        this.time = time;
    }
    accelerate(xforce, yforce) {
        this.acc = new Vector(xforce / this.mass, yforce / this.mass);
    }
    below_terrain(terrain) { // FIXME
        const elev = terrain.elevation(this.loc.x);
        return this.loc.y < elev;
    }
    stop() {
        this.vel.x = this.vel.y = 0;
        this.acc.x = this.acc.y = 0;
    }
    update(time) {
        const dt = time - this.time;
        this.loc.add(this.vel.mul(dt));
        this.vel.add(this.acc.mul(dt));
        this.time = time;
    }
}; // class MassiveObject

// --------------------------------------------------------------------
class Ship extends MassiveObject {
    constructor(x, y, w, h, xpos, ypos) {
        super(x, y, w, h, xpos, ypos, config.ship_mass, now());
        this.bot_thrust = 0;
        this.side_thrust = 0;
        this.cargo = 0;
        this.max_cargo = config.ship_max_cargo;
        this.fuel = 0;
        this.max_fuel = config.max_fuel;
        this.flying = false;
        this.inport = null;
    }
    load_ore(deposit) {
        if (deposit + this.cargo > this.max_cargo)
            deposit = this.max_cargo - this.cargo;
        this.cargo += deposit;
        this.mass += deposit;
        return deposit;
    }
    unload_ore() {
        const cargo = this.cargo;
        this.mass -= cargo;
        this.cargo = 0;
        return cargo;
    }
    add_fuel(fuel) {
        if (fuel + this.fuel > this.max_fuel)
            fuel = this.max_fuel - this.fuel;
        this.fuel += fuel;
        return fuel;
    }
    use_fuel(fuel) {
        this.fuel -= fuel;
        if (this.fuel < 0) {
            this.fuel = 0;
            Game._game_over("Your ship ran out of fuel!");
        }
    }
    set_bot_thrust(on, supercharge = false) {
        if (!this.flying && on) this.liftoff();
        this.bot_thrust = supercharge ? config.ship_bot_thrust*3 : on ? config.ship_bot_thrust : 0;
    }
    set_side_thrust(left, on) {
        if (!this.flying) return;
        this.side_thrust = !on ? 0 : left ? config.ship_side_thrust : -config.ship_side_thrust;
    }
    liftoff() {
        this.flying = true;
        this.vel.y = config.liftoff_vel;
        this.use_fuel(config.liftoff_fuel);
        this.set_status("Lift-off!");
    }
    land(terrain) {
        this.flying = false;
        this.bot_thrust = this.side_thrust = 0;
        this.stop();
        this.loc.y = terrain.elevation(this.loc.x);
        this.set_status("Landed safely.");
    }
    enter_port(port) {
        this.inport = port;
        this.set_status("In port "+port.name+".");
    }
    exit_port() {
        this.set_status("Left port "+this.inport.name+".");
        this.inport = null;
    }
    prospect(deposits) {
        const deposit = deposits.closest(this.loc.x);
        if (deposit == null || Math.abs(deposit.xpos - this.loc.x) > config.deposit_dig_max_dist) {
            this.set_status("No ore deposits found here.");
            return 0;
        }
        const loaded = this.load_ore(deposit.mass);
        deposit.mass -= loaded;
        if (deposit.mass == 0)
            this.set_status("Loaded "+loaded.toString()+" tons of ore!");
        else if (loaded == 0)
            this.set_status("Ship is full; cannot load any more ore.");
        else
            this.set_status("Loaded "+loaded.toString()+" tons of ore. Leaving "+deposit.mass.toString()+" tons because ship is full.");
        return loaded;
    }
    update(time) {
        const dt = time - this.time;
        super.update(time);
        const fuel_used = (this.bot_thrust + Math.abs(this.side_thrust)) * config.fuel_per_thrust * dt;
        this.use_fuel(fuel_used);
        if (this.flying)
            this.accelerate(this.side_thrust, this.bot_thrust - config.gravity);
    }
    set_status(msg) {
        Game._set_status(msg); // FIXME
    }
    draw(gfx, xpos) {
        const x = this.x + this.loc.x - xpos;
        const y = this.y + this.h - this.loc.y;
        const r = this.w * 0.02;
        this.draw_body(gfx, x, y, r);
        if (this.bot_thrust > 0) this.draw_bot_thrust(gfx, x, y, r);
        if (this.side_thrust < 0) this.draw_side_thrust(gfx, x, y, r, false);
        if (this.side_thrust > 0) this.draw_side_thrust(gfx, x, y, r, true);
    }
    draw_body(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_ship.jstring();
        ctx.beginPath();
        const H = r*.2;
        const W = r*.4;
        ctx.moveTo(x, y);
        ctx.lineTo(x-W, y+H);
        ctx.lineTo(x, y-r);
        ctx.lineTo(x+W, y+H);
        ctx.fill();
    }
    draw_bot_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        const W = r*.2;
        const L = r*1.7;
        const D = r*0.1;
        ctx.moveTo(x+W, y+D);
        ctx.lineTo(x, y+L); // tail
        ctx.lineTo(x-W, y+D);
        ctx.fill();
    }
    draw_side_thrust(gfx, x, y, r, left) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        var W = r*.15;
        var L = r*2.0;
        var D = r*0.5;
        if (left) { D = -D; L = -L; }
        y -= r*.05;
        ctx.moveTo(x+D, y-W);
        ctx.lineTo(x+L, y); // tail
        ctx.lineTo(x+D, y+W);
        ctx.fill();
    }
}; // class Ship

class ShipFuelFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.fuel; }
};

class ShipCargoFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.cargo; }
};

class ShipAltitudeFetcher {
    constructor(ship, terrain) { this.ship = ship; this.terrain = terrain; }
    gauge_value() { return this.ship.loc.y - this.terrain.elevation(this.ship.loc.x); }
};

class ShipFlyingStateFetcher {
    constructor(ship) { this.ship = ship; }
    button_state() { return this.ship.flying ? 1 : 0; }
};

// --------------------------------------------------------------------
class Dash extends Form {
    constructor(x, y, w, h, ship, terrain) {
        const b   = w * .01;
        const p1w = w * .12;
        const p2w = w * .16;
        const p3w = w * .30;
        const p4w = w - (p1w + p2w + p3w + 5*b);
        const p1x = x + b;
        const p2x = p1x + p1w + b;
        const p3x = p2x + p2w + b;
        const p4x = p3x + p3w + b;
        const gw = Math.floor((p2w-2*b)/ 3);
        const gh = h - 2*b;
        const dirw = p2w * 0.25;
        const dirh = dirw;
        const b3w = (p3w-b) / 2;
        const b3h = Math.floor((h-4*b) / 3);
        const p3x2 = p3x + b3w + b;
        const p3y2 = y+b+b3h+b;
        const p3y3 = p3y2+b3h+b;
        super(x, y, w, h, config.color_dash_bg);
        this.alt_gauge = new AltitudeGauge(p1x, y+b, gw, gh, ship, terrain);
        this.ore_gauge = new OreGauge(p1x+gw+b, y+b, gw, gh, ship);
        this.fuel_gauge = new FuelGauge(p1x+2*(gw+b), y+b, gw, gh, ship);
        this.ore_detector = new OreDetector(p4x, y+b, p4w, b3h);
        this.port_map = new PortMap(p4x, p3y2, p4w, b3h);
        this.live_status = new LiveStatus(p4x, p3y3, p4w, b3h);
        this.add(new ScoopButton(p3x, y+b, b3w, b3h));
        this.add(new LSIButton(p3x, p3y2, b3w, b3h));
        this.add(new FlyingButton(p3x, p3y3, b3w, b3h, ship));
        this.add(new OreDetectorButton(p3x2, y+b, b3w, b3h));
        this.add(new PortMapButton(p3x2, p3y2, b3w, b3h));
        this.add(new LiveStatusButton(p3x2, p3y3, b3w, b3h));
        this.add(new SouthButton(p2x + (p2w-dirw)/2, y + h/2, dirw, dirh));
    }
    set_status(status) {
        this.live_status.set_status(status);
    }
    draw(gfx) {
        super.draw(gfx);
        this.alt_gauge.draw(gfx);
        this.ore_gauge.draw(gfx);
        this.fuel_gauge.draw(gfx);
        this.ore_detector.draw(gfx);
        this.port_map.draw(gfx);
        this.live_status.draw(gfx);
    }
}; // class Dash

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.user_acct = new Account(10000);
        const canvas = gfx.ctx.canvas;
        const cw = canvas.width;
        const ch = canvas.height;
        this.x = 0;
        this.y = 0;
        this.w = cw;
        this.h = ch;
        const space = Math.floor(ch*.01);
        const dash_h = Math.floor(ch*.30);
        const dash_y = ch - dash_h;
        const view_y = 0;
        const view_h = dash_y - space - view_y;
        const mb = Math.floor(ch*.25);

        this.playing = true;
        this.msgrect = { x:mb, y:mb, w:cw-2*mb, h:ch-2*mb };
        this.terrain = new Terrain(0, view_y, cw, view_h);
        this.ports = new Ports(0, view_y, cw, view_h, this.terrain);
        this.deposits = new OreDeposits(0, view_y, cw, view_h, this.terrain);
        const shipxpos = 1000; // FIXME
        const shipypos = this.terrain.elevation(shipxpos);
        this.ship = new Ship(0, view_y, cw, view_h, shipxpos, shipypos);
this.ship.add_fuel(this.ship.max_fuel/3);
        this.dash = new Dash(0, dash_y, cw, dash_h, this.ship, this.terrain);
        this.view = new LiveView(0, view_y, cw, view_h, this.ship, this.terrain, this.ports, this.deposits);
        this.status = null;
        this.message = null;
        this.forms = [ this.dash ];
        this.need_sell = -1;
    }
    exit_port() {
        this.ship.exit_port();
    }
    pop_form() {
        this.forms.pop();
    }
    run() {
        if (!this.playing) return;
        const time = now();
        const ship = this.ship;
        const was_flying = ship.flying;
        ship.update(time);
        if (ship.flying && ship.below_terrain(this.terrain)) {
            if (ship.vel.norm2() > config.crash_vel2) {
                this.game_over("You crashed!");
            } else {
                ship.land(this.terrain);
            }
        }
        this.draw();
        if (ship.flying && !was_flying) { // liftoff
            if (ship.inport != null) {
                // FIXME wait this can't really happen, right? ship just spontaneously takes off while in the menu?
                this.exit_port();
            }
        } else if (!ship.flying && was_flying) { // landing
            const land_port = this.view.ports.can_land(ship.loc.x);
            if (land_port != null) {
                ship.enter_port(land_port);
                const xb = Math.floor(this.w * 0.10);
                const yb = xb;
                const menu = new PortMenu(this.x+xb, this.y+yb, this.w-2*xb, this.h-2*yb, land_port);
                this.forms.push(menu.init());
            } else {
                const loaded = ship.prospect(this.deposits);
            }
        }
        if (this.need_sell >= 0) {
            const xb = Math.floor(this.w * 0.20);
            const yb = xb;
            const menu = new SellMenu(this.x+xb, this.y+yb, this.w-2*xb, this.h-2*yb, ship, this.need_sell);
            this.forms.push(menu.init());
            this.need_sell = -1;
        }
    }
    set_status(status) {
        this.dash.set_status(status);
    }
    draw() {
        const sxpos = this.ship.loc.x - this.terrain.w;
        const expos = this.ship.loc.x + this.terrain.w;
        this.terrain.cover(sxpos, expos);
        this.ports.cover(sxpos, expos);
        this.deposits.cover(sxpos, expos);

        this.gfx.clear(config.color_sky);
        this.view.draw(this.gfx);
        for (let i = 0; i < this.forms.length; ++i) {
            this.forms[i].draw(this.gfx);
        }
        this.draw_message();
    }
    static _set_status(status) { // kinda ugly
        if (_game != null) _game.set_status(status);
    }
    static _event_keydown(e) {
        if (_game != null) _game.event_keystroke(e.code, true);
    }
    static _event_keyup(e) {
        if (_game != null) _game.event_keystroke(e.code, false);
    }
    static _event_mousedown(e) {
        if (_game != null) _game.event_mouse(true, e.offsetX, e.offsetY);
    }
    static _event_mouseup(e) {
        if (_game != null) _game.event_mouse(false, e.offsetX, e.offsetY);
    }
    static _game_over(msg) {
        if (_game != null) _game.game_over(msg);
    }
    event_keystroke(code, down) {
        this.set_thrust(code, down);
        //this.draw();
    }
    event_mouse(down, x, y) {
        if (this.forms.length == 0) return;
        this.forms[this.forms.length-1].mouse(down, x, y);
    }
    set_thrust(code, on) {
        switch (code) {
        case 'ArrowDown':
            this.ship.set_bot_thrust(on);
            break;
        case 'ArrowUp':
            this.ship.set_bot_thrust(on, on);
            break;
        case 'ArrowRight':
            this.ship.set_side_thrust(false, on);
            break;
        case 'ArrowLeft':
            this.ship.set_side_thrust(true, on);
            break;
        }
    }
    game_over(msg) {
        this.message = "Game over: "+msg;
        this.draw();
        this.playing = false;
    }
    draw_message() {
        if (this.message == null) return;
        const b = 5;
        this.gfx.draw_outlined_rect(this.msgrect.x, this.msgrect.y, this.msgrect.w, this.msgrect.h, b, b, config.color_msg_bg, config.color_msg_border);
        const text_size = this.gfx.measure_text(this.message);
        const y = this.msgrect.y + (this.msgrect.h - text_size.height) / 2;
        this.gfx.draw_centered_text(this.msgrect.x, y, this.msgrect.w, this.message, config.color_msg_fg);
    }
}; // class Game

// --------------------------------------------------------------------

function now() {
    return performance.now();
}

function run_game() {
    if (_game != null) _game.run();
    window.requestAnimationFrame(run_game);
}

function canvas_resize() {
    const s = 20;
    const canvas = el("canvas");
    canvas.width = window.innerWidth - s;
    canvas.height = window.innerHeight - s;
}

function munge_config() {
    for (const [key,value] of Object.entries(config)) {
        if (key.substr(0,6) == "color_")
            config[key] = new Color(config[key]);
    }
}

function el(name) {
    return document.getElementById(name);
}

function hex2(n) {
    let hex = Math.floor(n).toString(16);
    while (hex.length < 2) hex = "0"+hex;
    return hex;
}

function nhash(n) {
    let r = 0;
    for (let i = 0; i < 32; ++i) {
        const bit = n ^ (n >> 2) ^ (n >> 3) ^ (n >> 5);
        n = (n >> 1) | (bit << 15);
    }
    return Math.abs(n);
}

function randu(n) {
    return Math.floor(Math.random() * n);
}

function main() {
    munge_config();
    canvas_resize();
    const canvas = el("canvas");
    const gfx = new Graphics(canvas.getContext("2d"));
    gfx.ctx.font = Math.floor(canvas.height*.028).toString()+"px sans-serif";
    _game = new Game(gfx);
    document.addEventListener('keyup',   Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    document.addEventListener('mousedown',   Game._event_mousedown);
    document.addEventListener('mouseup',   Game._event_mouseup);
    window.addEventListener('resize', canvas_resize, false);
    run_game();
}

</script>
</body>
</html>


