<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Asteroid Miner</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>
<canvas id="canvas2" width="100" height="100" style="font-family:Arial; display:none"></canvas>
<script>

// TODO
// anti-bounce landing

// --------------------------------------------------------------------
// Globals
var _game = null;
var _held = null;

//#define UP_ARROW    "\u25b2"
//#define DOWN_ARROW  "\u25bc"
//#define RIGHT_ARROW "\u25b6"
//#define LEFT_ARROW  "\u25c0"

var config = {
    button_border          : 3,
    crash_vel2             : .04,
    crit_fuel              : 2,
    deposit_dig_max_dist   : 10,
    deposit_screens_per    : 1,
    fuel_per_thrust        : .04,
    gauge_border           : 3,
    gravity                : 0.002,
    grid_step              : 100,
    grid_len               : 10,
    grid_thick             : 2,
    liftoff_fuel           : 1,
    liftoff_vel            : 0.02,
    low_fuel               : 10,
    max_fuel               : 100,
    menu_border            : 4,
    menu_yfrac             : .75,
    min_elev               : 10,
    numin_btn_border       : 1,
    ore_mass_max           : 60,
    ore_mass_min           : 8,
    ore_sep                : 350,
    port_screens_per       : 5,
    port_sep               : 1200,
    port_land_max_dist     : 10,
    resmap_range_mult      : 8,
    ship_bot_thrust        : 0.004,
    ship_mass              : 50,
    ship_max_cargo         : 200,
    ship_side_thrust       : 0.01,
    terr_base              : 24, // pixels
    terr_step              : 22, // pixels

    color_bank_bg          : "007000",
    color_bank_fg          : "ffffff",
    color_btn_active       : "10ff40",
    color_btn_active_fg    : "000000",
    color_btn_dir          : "1050c0",
    color_btn_dir_fg       : "000000",
    color_btn_inactive     : "c08010",
    color_btn_inactive_fg  : "000000",
    color_btn_none         : "a0a0a0",
    color_btn_none_fg      : "383838",
    color_clock_bg         : "e0e0e0",
    color_clock_border     : "000000",
    color_clock_fg         : "000000",
    color_dash_bg          : "bec2cb",
    color_fuel             : "40a0f0",
    color_gauge_bg         : "e0e0e0",
    color_gauge_border     : "a098b0",
    color_gauge_crit       : "ff1010",
    color_gauge_low        : "a06000",
    color_gauge_text       : "000000",
    color_gauge_title      : "000000",
    color_debugrid         : "f0f0e0",
    color_msg_bg           : "c0c0c0",
    color_msg_fg           : "000000",
    color_msg_border       : "ff0000",
    color_menu_bg          : "40ffff",
    color_menu_fg          : "000000",
    color_menu_border      : "000000",
    color_menu_btn_bg      : "2050c0",
    color_menu_btn_fg      : "ffffff",
    color_menu_btn_held    : "ffff00",
    color_menu_hdr_fg      : "000000",
    color_numin_bg         : "00ffff",
    color_numin_btn_bg     : "c0c0c0",
    color_numin_btn_fg     : "000000",
    color_ore              : "d4af37",
    color_port             : "f0f0f0",
    color_resmap_bg        : "a8a818",
    color_ship             : "10ffff",
    color_sky              : "000000",
    color_status_bg        : "d0d050",
    color_status_fg        : "000000",
    color_terrain          : "707070",
    color_thrust           : "ff3010",
};

// --------------------------------------------------------------------
class Color {
    constructor(hex) {
        this.hex_str = hex;
    }
    hex() {
        return this.hex_str;
    }
    jstring() {
        return "#" + this.hex_str;
    }
    get_comp(comp) {
        return parseInt(this.hex_str.substr(comp*2, 2), 16);
    }
    darker(mult) {
        return new Color(hex2(this.get_comp(0)*mult) + hex2(this.get_comp(1)*mult) + hex2(this.get_comp(2)*mult));
    }
    opposite() {
        return new Color(hex2(255-this.get_comp(0)) + hex2(255-this.get_comp(1)) + hex2(255-this.get_comp(2)));
    }
    contrast() {
        const bright = this.get_comp(0) + this.get_comp(1) + this.get_comp(2);
        return new Color((bright > (3*128)) ? "000000" : "ffffff");
    }
};

// --------------------------------------------------------------------
class Vector {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
    }
    mul(num) {
        return new Vector(this.x*num, this.y*num);
    }
    norm2() {
        return this.x*this.x + this.y*this.y;
    }
}; // class Vector

// --------------------------------------------------------------------
class Graphics {
    constructor(ctx, font_size) {
        this.ctx = ctx;
        ctx.font = Math.floor(font_size).toString()+"px sans-serif";
        this.font_height = font_size;
    }
    clear(color) {
        const canvas = this.ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;
        this.ctx.clearRect(0, 0, w, h);
        this.draw_rect(0, 0, w, h, color);
    }
    draw_rect(x, y, w, h, color) {
        if (color != undefined && color != null) this.ctx.fillStyle = color.jstring();
        this.ctx.fillRect(x, y, w, h);
    }
    draw_centered_rect(cx, cy, w, h, color) {
        this.draw_rect(cx - w/2, cy - h/2, w, h, color);
    }
    draw_outline(x, y, w, h, xb, yb, color) {
        this.draw_rect(x,      y,       w-xb,   yb,   color);
        this.draw_rect(x+w-xb, y,       xb,     h-yb, color);
        this.draw_rect(x+xb,   y+h-yb,  w-xb,   yb,   color);
        this.draw_rect(x,      y+yb,    xb,     h-yb, color);
    }
    draw_centered_outline(cx, cy, w, h, xb, yb, color) {
        this.draw_outline(cx - w/2, cy - h/2, w, h, xb, yb, color);
    }
    draw_outlined_rect(x, y, w, h, xb, yb, bg_color, border_color) {
        this.draw_rect(x+xb, y+yb, w-2*xb, h-2*yb, bg_color);
        this.draw_outline(x, y, w, h, xb, yb, border_color);
    }
    draw_circle(x, y, r, color) {
        this.ctx.beginPath();
        this.ctx.fillStyle = color.jstring();
        this.ctx.arc(x, y, r, 0, 2*Math.PI);
        this.ctx.fill();
    }
    draw_text(x, y, text, color) {
        this.ctx.fillStyle = color.jstring();
        this.ctx.fillText(text, x, y+this.font_height);
    }
    measure_text(text) {
        let max_width = 0;
        let num_lines = 0;
        for (let line of text.split("\n")) {
            const text_size = this.ctx.measureText(line);
            if (text_size.width > max_width) max_width = text_size.width;
            ++num_lines;
        }
        return { width: max_width, height: this.font_height * num_lines };
    }
    draw_centered_text(x, y, w, text, color) {
        const text_size = this.measure_text(text);
        const nx = x + (w - text_size.width) / 2;
        if (nx > x) x = nx;
        this.draw_text(x, y, text, color);
        return text_size;
    }
    static end_word(text, p) {
        for (; p < text.length; ++p) {
            if (text.substr(p,1) != " ") break;
        }
        for (; p < text.length; ++p) {
            if (text.substr(p,1) == " " || text.substr(p,1) == "\n") break;
        }
        return p;
    }
    split_text(text, width) {
        let lines = [];
        let line = 0;
        for (;;) {
            // Skip spaces.
            while (text.substr(line,1) == " ")
                ++line;
            let end_line = line;
            // Output line starts here; step thru words.
            for (;;) {
                if (end_line >= text.length) {
                    if (end_line > line) lines.push(text.substr(line, end_line-line));
                    return lines;
                }
                const newline = (text.substr(end_line,1) == "\n");
                let e = -1;
                if (!newline) e = Graphics.end_word(text, end_line);
                if (newline || this.measure_text(text.substr(line, e-line)).width >= width) {
                    if (end_line == line && !newline) { // we must break a word
                        while (e > line && this.measure_text(text.substr(line, e-line)).width >= width)
                            e = e - 1;
                        end_line = e;
                    }
                    lines.push(text.substr(line, end_line-line));
                    line = end_line;
                    if (newline) ++line;
                    break;
                }
                end_line = e;
            }
        }
    }
    draw_paragraph(msg, x, y, w, color, center = false, list_char = "") {
        const lines = this.split_text(msg, w);
        const line_h = this.font_height;
        const list_indent = (list_char.length == 0) ? 0 : this.measure_text(list_char).width;
        for (let i = 0; i < lines.length; ++i) {
            let line = lines[i];
            let tx = x;
            let center_line = center;
            if (line.substr(0,1) == "\t") {
                center_line = true;
                line = line.substr(1);
            }
            if (center_line) {
                const tw = this.measure_text(line).width;
                tx += Math.floor((w - tw) / 2);
            }
            if (list_char.length > 0 && line.substr(0,list_char.length) != list_char)
                tx += list_indent;
            this.draw_text(tx, y, line, color);
            y += line_h;
        }
        return { w: w, h: lines.length * line_h };
    }
    draw_vcentered_paragraph(msg, x, y, w, h, color, center = false, list_char = "") {
        const msg_size = this.measure_text(msg);
        y += (h - msg_size.height) / 2;
        return this.draw_paragraph(msg, x, y, w, color, center, list_char);
    }
}; // class Graphics

// --------------------------------------------------------------------
class Drawable {
    constructor(x, y, w, h) {
        this.move(x, y, w, h);
    }
    move(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
    }
    mouse(down, x, y) {
        return false;
    }
    draw(gfx) {
    }
    measure(gfx) {
        return { w:this.w, h:this.h };
    }
}; // class Drawable

// --------------------------------------------------------------------
class Layout extends Drawable {
    constructor(x, y, w, h, form, rows, row_height, cols, col_width, row_sp=4, col_sp=4) {
        if (row_height.length != rows || col_width.length != cols) return null;
        super(x, y, w, h);
        this.form = form;
        this.rows = rows;
        this.cols = cols;
        this.col_width = col_width;
        this.row_height = row_height;
        this.row_sp = row_sp;
        this.col_sp = col_sp;
        this.items = [];
        for (let row = 0; row < rows; ++row) {
            this.items.push([]);
            for (let col = 0; col < cols; ++col) {
                this.items[row].push(null);
            }
        }
        this.needs_layout = true;
    }
    add(row, col, drawable, rowspan = 1, colspan = 1) {
        this.items[row][col] = { dr:drawable, rowspan:rowspan, colspan:colspan };
    }
    mouse(down, x, y) {
        for (let row = 0; row < this.rows; ++row) {
            for (let col = 0; col < this.cols; ++col) {
                const item = this.items[row][col];
                if (item != null && item.dr.mouse(down, x, y))
                    return true;
            }
        }
        return false;
    }
    drawable(row, col) {
        const item = this.items[row][col];
        if (item == null) return null;
        return item.dr;
    }
    layout(gfx) {
        let y = this.y + this.row_sp;
        let max_w = 0;
        for (let row = 0; row < this.rows; ++row) {
            let row_h = this.row_height[row];
            //if (row_h < 0) row_h = this.h - y - this.row_sp;
            let x = this.x + this.col_sp;
            for (let col = 0; col < this.cols; ++col) {
                let col_w = this.col_width[col];
                if (col_w < 0) col_w = this.w - x - this.col_sp;
                const item = this.items[row][col];
                if (item != null) {
                    let draw_x = x;
                    let draw_y = y;
                    let iw = col_w;
                    for (let i = 1; i < item.colspan; ++i) {
                        const cw = this.col_sp + this.col_width[col-i];
                        iw += cw;
                        draw_x -= cw;
                    }
                    let ih = row_h;
                    for (let i = 1; i < item.rowspan; ++i) {
                        const rh = this.row_sp + this.row_height[row-i];
                        ih += rh;
                        draw_y -= rh;
                    }
                    item.dr.move(draw_x, draw_y, iw, ih); // !!!
                    const size = item.dr.measure(gfx);
                    if (draw_y + ih > y + row_h)
                        row_h = draw_y + ih - y;
                }
                x += col_w + this.col_sp;
                if (col_w > max_w) max_w = col_w;
            }
            y += row_h + this.row_sp;
        }
    }
}; // class Layout

// --------------------------------------------------------------------
class TextBox extends Drawable {
    constructor(x, y, w, h, text, bg, fg) {
        super(x, y, w, h);
        this.text = text;
        this.bg = bg;
        this.fg = fg;
    }
    set_text(text) {
        this.text = text;
    }
    draw(gfx) {
        if (this.bg != null) gfx.draw_rect(this.x, this.y, this.w, this.h, this.bg);
        if (this.fg != null) gfx.draw_paragraph(this.text, this.x, this.y, this.w, this.fg);
    }
}; // class TextBox

// --------------------------------------------------------------------
class Gauge extends Drawable {
    constructor(x, y, w, h, title, color, max_value, low_value = -1, crit_value = -1, fetcher = null) {
        super(x, y, w, h);
        this.title = title;
        this.color = color;
        this.max_value = max_value;
        this.low_value = low_value;
        this.crit_value = crit_value;
        this.fetcher = fetcher;
        this.value = 0;
    }
    set_value(value) {
        if (value < 0) value = 0;
        if (value > this.max_value) value = this.max_value;
        this.value = value;
    }
    get_value(value) {
        return this.value;
    }
    draw(gfx) {
        if (this.fetcher != null)
            this.set_value(this.fetcher.gauge_value());
        let title_size = gfx.draw_centered_text(this.x, this.y, this.w, this.title, config.color_gauge_title);
        const gh = this.h - title_size.height *1.5;
        const gb = config.gauge_border;
        const inh = gh - 2*gb;
        const inw = this.w - 2*gb;
        const barh = inh * this.value / this.max_value;
        const bot = this.y + this.h;
        const value_text = Math.floor(this.value).toString();
        const value_text_size = gfx.measure_text(value_text);
        gfx.draw_outlined_rect(this.x, bot-gh, this.w, gh, gb, gb, config.color_gauge_bg, config.color_sky);
        gfx.draw_rect(this.x+gb, bot-gb-barh, inw, barh, this.color);
        ///gfx.draw_rect(this.x+gb, bot-gb-barh-2, inw, 2, this.color.darker(.5));
        gfx.draw_centered_text(this.x, bot-value_text_size.height*1.5, this.w, value_text, config.color_gauge_text);
        let ctext = null;
        let ccolor = null;
        if (this.value <= this.crit_value) {
            ctext = "DANGER"; ccolor = config.color_gauge_crit;
        } else if (this.value <= this.low_value) {
            ctext = "LOW"; ccolor = config.color_gauge_low;
        } else if (this.value >= this.max_value) {
            ctext = "MAX"; ccolor = config.color_gauge_text;
        }
        if (ctext != null)
            gfx.draw_centered_text(this.x, this.y+this.h/2-value_text_size.height/2, this.w, ctext, ccolor);
    }
}; // class Gauge

// --------------------------------------------------------------------
class FuelGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Fuel", config.color_fuel, config.max_fuel, config.low_fuel, config.crit_fuel, new ShipFuelFetcher(ship));
    }
}; // class FuelGauge

// --------------------------------------------------------------------
class OreGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Cargo", config.color_ore, ship.max_cargo, -1, -1, new ShipCargoFetcher(ship));
    }
}; // class OreGauge

// --------------------------------------------------------------------
class AltitudeGauge extends Gauge {
    constructor(x, y, w, h, ship, terrain) {
        super(x, y, w, h, "Alt.", config.color_terrain, terrain.max_elev, -1, -1, new ShipAltitudeFetcher(ship, terrain));
    }
}; // class AltitudeGauge

// --------------------------------------------------------------------
class Button extends Drawable {
    constructor(x, y, w, h, border, state_titles, state_colors_bg, state_colors_fg, state, holdable = false, state_fetcher = null, title_fetcher = null) {
        super(x, y, w, h);
        this.state_titles = state_titles;
        this.state_colors_bg = state_colors_bg;
        this.state_colors_fg = state_colors_fg;
        this.state = state;
        this.state_fetcher = state_fetcher;
        this.title_fetcher = title_fetcher;
        this.holdable = holdable;
        this.border = (border >= 0) ? border : config.button_border;
    }
    set_state(state) {
        this.state = state;
    }
    set_title(title) {
        this.state_titles[this.state] = title;
    }
    inside(x, y) {
        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
    }
    mouse(down, x, y) {
        if (!this.holdable || !this.inside(x, y))
            return false;
        if (down) {
            _held = this;
            this.click_down();
        } else {
            this.click_up();
        }
        return true;
    }
    click_down() {
    }
    click_up() {
    }
    draw(gfx) {
        if (this.state_fetcher != null)
            this.state = this.state_fetcher.button_state();
        let title = this.state_titles[this.state];
        if (this.title_fetcher != null) {
            let ftitle = this.title_fetcher.get_title();
            if (ftitle != null) title = ftitle;
        }
        const color = (this == _held) ? config.color_menu_btn_held : this.state_colors_bg[this.state];
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, this.border, this.border, color, config.color_sky);
        gfx.draw_vcentered_paragraph(title, this.x, this.y, this.w, this.h, this.state_colors_fg[this.state], true);
    }
}; // class Button

// --------------------------------------------------------------------
class Form extends Drawable {
    constructor(x, y, w, h, bg) {
        super(x, y, w, h);
        this.bg = bg;
        this.children = [];
    }
    add(child) {
        this.children.push(child);
        return child;
    }
    update_form() {
    }
    mouse(down, x, y) {
        for (const child of this.children) {
            if (child.mouse(down, x, y))
                return true;
        }
        return false;
    }
    draw(gfx) {
        gfx.draw_rect(this.x, this.y, this.w, this.h, this.bg);
        for (const btn of this.children)
            btn.draw(gfx);
    }
}; // class Form

// --------------------------------------------------------------------
class MenuButton extends Button {
    constructor(menu, title, slot) {
        super(menu.btn_x, menu.btn_y + slot * (menu.btn_h + menu.btn_sp), menu.btn_w, menu.btn_h, config.button_border,
            [title], [config.color_menu_btn_bg], [config.color_menu_btn_fg], 0, true);
        this.slot = slot;
    }
    click_down() {
        this.click_menu_button(this.slot);
    }
}; // class MenuButton

// --------------------------------------------------------------------
class NoMenuButton extends MenuButton {
    constructor(menu, title, slot) {
        super(menu, title, slot);
    }
    click_menu_button(slot) {
        _game.pop_form();
    }
}; // class NoMenuButton

// --------------------------------------------------------------------
class NumberInputButton extends Button {
    constructor(x, y, w, h, digit, incr) {
        super(x, y, w, h, config.numin_btn_border,
            (incr > 0) ? ["\u25b2"] : ["\u25bc"], [config.color_numin_btn_bg], [config.color_numin_btn_fg], 0, true);
        this.digit = digit;
        this.incr = incr;
    }
    click_down() {
        this.digit.value += this.incr;
        if (this.digit.value < 0)
            this.digit.value = 0;
        else if (this.digit.value > 9)
            this.digit.value = 9;
    }
}; // class NumberInputButton

// --------------------------------------------------------------------
class NumberInputDigit extends Drawable {
    constructor(x, y, w, h, i) {
        super(x, y, w, h);
        const btn_h = Math.floor(h/3);
        this.up_btn = new NumberInputButton(x, y, w, btn_h, this, +1);
        this.down_btn = new NumberInputButton(x, y+h-btn_h, w, btn_h, this, -1);
        this.digit_char_x = x;
        this.digit_char_y = y + btn_h;
        this.digit_char_w = w;
        this.digit_char_h = btn_h;
        this.value = 0;
    }
    set_value(d) {
        this.value = d;
    }
    mouse(down, x, y) {
        for (const btn of [this.up_btn, this.down_btn]) {
            if (btn.inside(x, y)) {
                if (down) btn.click_down(); else btn.click_up();
                return true;
            }
        }
        return false;
    }
    draw(gfx) {
        this.up_btn.draw(gfx, false);
        this.down_btn.draw(gfx, false);
        gfx.draw_vcentered_paragraph(this.value.toString(), 
            this.digit_char_x, this.digit_char_y, this.digit_char_w, this.digit_char_h,
            config.color_btn_dir, true);
    }
}; // class NumberInputButton

// --------------------------------------------------------------------
class NumberInput extends Form {
    constructor(x, y, w, h, num_digits, max) {
        super(x, y, w, h, config.color_numin_bg);
        const digit_sp = 0.2;
        const digit_w = w / (num_digits + digit_sp * (num_digits-1));
        this.digits = [];
        this.max = max;
        let dx = x + w - digit_w;
        for (let i = 0; i < num_digits; ++i) {
            const digit = new NumberInputDigit(dx, y, digit_w, h);
            dx -= digit_w * (1+digit_sp);
            this.digits.push(digit);
            this.add(digit);
        }
    }
    mouse(down, x, y) {
        const r = super.mouse(down, x, y);
        if (r) {
            if (this.get_value() > this.max)
                this.set_value(this.max);
        }
        return r;
    }
    get_value() {
        let v = 0;
        for (let i = this.digits.length-1; i >= 0; --i)
            v = (10 * v) + this.digits[i].value;
        return v;
    }
    set_value(v) {
        v = Math.floor(v);
        for (let i = 0; i < this.digits.length; ++i) {
            this.digits[i].set_value(v % 10);
            v = Math.floor(v/10);
        }
    }
}; // class NumberInput

// --------------------------------------------------------------------
class Menu extends Form {
    constructor(x, y, w, h, desc) {
        super(x, y, w, h, config.color_menu_bg);
        this.desc_box = new TextBox(x, y, w, h, desc, null, config.color_menu_fg);
        this.set_desc(desc);
    }
    set_desc(desc) {
        this.desc_box.set_text(desc);
        this.desc = desc;
        ///FIXME
        this.btn_w = Math.floor(this.w * 0.6);
        this.btn_h = Math.floor(this.h * 0.10);
        this.btn_sp = Math.floor(this.btn_h * .3);
        this.btn_x = this.x + (this.w - this.btn_w) / 2;
        this.btn_y = this.y + this.btn_h*3.5;
    }
    draw(gfx) {
        super.draw(gfx);
        this.desc_box.draw(gfx);
        gfx.draw_outline(this.x, this.y, this.w, this.h, config.menu_border, config.menu_border, config.color_menu_border);
    }
}; // class Menu

// --------------------------------------------------------------------
class YesSellOreMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "Yes", slot);
        this.menu = menu;
    }
    click_menu_button(slot) {
        const cargo = this.menu.ship.unload_ore();
        this.menu.acct.add_cash(this.menu.price * cargo, "Sale of "+cargo.toString()+" tons ore");
        _game.pop_form();
    }
}; // class YesSellOreMenuButton

// --------------------------------------------------------------------
class ConfirmSellOreMenu extends Menu {
    constructor(x, y, w, h, ship, acct, price) {
        super(x, y, w, h, "Do you want to sell the "+ship.cargo.toString()+" tons of cargo in your ship for $"+currency(ship.cargo*price)+"?");
        this.ship = ship;
        this.acct = acct;
        this.price = price;
    }
    init() {
        this.add(new YesSellOreMenuButton(this, 0));
        this.add(new NoMenuButton(this, "No", 1));
        return this;
    }
}; // class ConfirmSellOreMenu

// --------------------------------------------------------------------
class SellOreButton extends MenuButton {
    constructor(menu, price) {
        super(menu, "Sell ore at $"+price.toString()+" per ton", 0);
        this.price = price;
        this.menurect = { x:menu.x, y:menu.y, w:menu.w, h:menu.h }; 
    }
    click_menu_button(slot) {
        if (_game == null) return;
        const menu = new ConfirmSellOreMenu(this.menurect.x,  this.menurect.y,  this.menurect.w,  this.menurect.h, _game.ship, _game.acct, this.price);
        _game.forms.push(menu.init());
    }
}; // class SellOreButton

// --------------------------------------------------------------------
class YesBuyFuelMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "Yes", slot);
        this.menu = menu;
    }
    click_menu_button(slot) {
        const fuel = this.menu.ship.add_fuel(this.menu.fuel);
        const cost = fuel * this.menu.price;
        this.menu.acct.remove_cash(cost, "Buy "+fuel.toString()+" liters fuel");
        _game.set_status("Bought "+fuel.toString()+"L fuel for $"+cost.toString());
        _game.pop_form();
    }
}; // class YesBuyFuelMenuButton

// --------------------------------------------------------------------
class ConfirmBuyFuelMenu extends Menu {
    constructor(x, y, w, h, ship, acct, fuel, price) {
        super(x, y, w, h, "Do you want to buy "+fuel.toString()+" L of fuel for $"+(fuel*price).toString()+"?");
        this.ship = ship;
        this.acct = acct;
        this.fuel = fuel;
        this.price = price;
    }
    init() {
        this.add(new YesBuyFuelMenuButton(this, 0));
        this.add(new NoMenuButton(this, "No", 1));
        return this;
    }
}; // class ConfirmBuyFuelMenu

// --------------------------------------------------------------------
class OkBuyFuelMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "OK", slot);
        this.menu = menu;
        this.menurect = { x:menu.x, y:menu.y, w:menu.w, h:menu.h }; 
    }
    click_menu_button(slot) {
        if (_game == null) return;
        const menu = new ConfirmBuyFuelMenu(this.menurect.x,  this.menurect.y,  this.menurect.w,  this.menurect.h, 
            _game.ship, _game.acct, this.menu.fuel_input.get_value(), this.menu.price);
        _game.pop_form();
        _game.forms.push(menu.init());
    }
}; // class OkBuyFuelMenuButton 

// --------------------------------------------------------------------
class BuyFuelMenu extends Menu {
    constructor(x, y, w, h, ship, acct, price) {
        super(x, y, w, h, "How much fuel do you want to buy for $"+price.toString()+" per liter?");
        this.ship = ship;
        this.acct = acct;
        this.price = price;
    }
    init() {
        const top = 40;
        const digits = 4;
        const digitw = this.w * 0.03;
        const fi_w = digits * digitw;
        const fi_h = fi_w;
        const fi_x = this.x + (this.w - fi_w) /2
        this.fuel_input = new NumberInput(fi_x, this.btn_y, fi_w, fi_h, 4, Math.min(this.ship.max_fuel-this.ship.fuel, this.acct.balance/this.price));
        this.add(this.fuel_input);
        this.btn_y += fi_h + .75*this.btn_h;
        this.add(new OkBuyFuelMenuButton(this, 0));
        this.add(new NoMenuButton(this, "Cancel", 1));
        return this;
    }
}; // class BuyFuelMenu

// --------------------------------------------------------------------
class BuyFuelButton extends MenuButton {
    constructor(menu, price) {
        super(menu, "Buy fuel at $"+price.toString()+" per liter", 1);
        this.price = price;
        this.menurect = { x:menu.x, y:menu.y, w:menu.w, h:menu.h }; 
    }
    click_menu_button(slot) {
        if (_game == null) return;
        const menu = new BuyFuelMenu(this.menurect.x,  this.menurect.y,  this.menurect.w,  this.menurect.h,  _game.ship, _game.acct, this.price);
        _game.forms.push(menu.init());
    }
}; // class BuyFuelButton

// --------------------------------------------------------------------
class YesLoanMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "OK, I agree.", slot);
        this.menu = menu;
    }
    click_menu_button(slot) {
        this.menu.acct.loan = this.menu.loan;
        this.menu.acct.add_cash(this.menu.loan.amt);
        _game.pop_form();
    }
}; // class YesLoanMenuButton

// --------------------------------------------------------------------
class ConfirmLoanMenu extends Menu {
    constructor(x, y, w, h, acct, amt) {
        const loan = new Loan(amt);
        const msg = "We can offer you a loan of $"+currency(amt)+
            " with the understanding that you will repay $"+currency(loan.payoff)+
            " within "+dur_string(loan.due-now())+
            " minutes.\nIf you agree to these terms, please sign here.";
        super(x, y, w, h, msg);
        this.acct = acct;
        this.loan = loan;
    }
    init() {
        this.add(new YesLoanMenuButton(this, 0));
        this.add(new NoMenuButton(this, "Cancel", 1));
        return this;
    }
}; // class ConfirmLoanMenu

// --------------------------------------------------------------------
class OkLoanMenuButton extends MenuButton {
    constructor(menu, slot) {
        super(menu, "OK", slot);
        this.menu = menu;
        this.menurect = { x:menu.x, y:menu.y, w:menu.w, h:menu.h }; 
    }
    click_menu_button(slot) {
        if (_game == null) return;
        const menu = new ConfirmLoanMenu(this.menurect.x,  this.menurect.y,  this.menurect.w,  this.menurect.h, 
            _game.acct, this.menu.loan_input.get_value());
        _game.pop_form();
        _game.forms.push(menu.init());
    }
}; // class OkLoanMenuButton 

// --------------------------------------------------------------------
class LoanMenu extends Menu {
    constructor(x, y, w, h, acct) {
        super(x, y, w, h, "How much would you like to borrow?");
        this.acct = acct;
    }
    init() {
        const top = 40;
        const fih = this.h - this.btn_y - 2*this.btn_h - this.btn_sp - 1.5*this.btn_h;
        const xmargin = this.w * 0.1;
        this.loan_input = new NumberInput(this.x+xmargin, this.btn_y, this.w-2*xmargin, fih, 5);
        this.add(this.loan_input);
        this.btn_y += fih + .75*this.btn_h;
        this.add(new OkLoanMenuButton(this, 0));
        this.add(new NoMenuButton(this, "Cancel", 1));
        return this;
    }
}; // class LoanMenu

// --------------------------------------------------------------------
class LoanButton extends MenuButton {
    constructor(menu) {
        super(menu, "Borrow money", 2);
        this.menurect = { x:menu.x, y:menu.y, w:menu.w, h:menu.h }; 
    }
    click_menu_button(slot) {
        if (_game == null) return;
        const menu = new LoanMenu(this.menurect.x,  this.menurect.y,  this.menurect.w,  this.menurect.h,  _game.acct);
        _game.forms.push(menu.init());
    }
}; // class LoanButton

// --------------------------------------------------------------------
class EStoreButton extends MenuButton {
    constructor(menu) {
        super(menu, "Equipment store", 3);
    }
    click_menu_button(slot) {
        ///FIXME
    }
}; // class EStoreButton

// --------------------------------------------------------------------
class LeavePortButton extends MenuButton {
    constructor(menu) {
        super(menu, "Leave this port", 4);
    }
    click_menu_button(slot) {
        if (_game == null) return;
        _game.exit_port();
        _game.pop_form();
        _game.set_status("Ready for liftoff.");
    }
}; // class LeavePortButton

// --------------------------------------------------------------------
class PortMenu extends Menu {
    constructor(x, y, w, h, port, acct) {
        super(x, y, w, h, "");
        this.port = port;
        this.acct = acct;
    }
    init() {
        this.add(new SellOreButton(this, this.port.sell_ore_price()));
        this.add(new BuyFuelButton(this, this.port.buy_fuel_price()));
        if (this.acct.loan == null)
            this.add(new LoanButton(this));
        else
            this.add(new RepayButton(this));
        this.add(new EStoreButton(this));
        this.add(new LeavePortButton(this));
        this.set_desc(this.get_desc());
        return this;
    }
    update_form() {
        this.set_desc(this.get_desc());
    }
    get_desc() {
        return "Welcome to port "+this.port.name+"!\n";
    }
}; // class PortMenu

// --------------------------------------------------------------------
class ScoopButton extends Button {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            ["Ore scoop: off", "Ore scoop: on", "Ore scoop: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg],
            2, false);
        this.holdable = (this.state != 2);
    }
    click_down() {
    }
}; // class ScoopButton

// --------------------------------------------------------------------
class LSIButton extends Button {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            ["LSI: off", "LSI: on"],
            [config.color_btn_inactive, config.color_btn_active],
            [config.color_btn_inactive_fg, config.color_btn_active_fg], 0, true);
    }
    click_down() {
        this.set_state((this.state == 0) ? 1 : 0);
    }
}; // class LSIButton

// --------------------------------------------------------------------
class FlyingButton extends Button {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, config.button_border,
            ["On ground", "Flying"],
            [config.color_btn_inactive, config.color_btn_active],
            [config.color_btn_inactive_fg, config.color_btn_active_fg],
            0, false, new ShipFlyingStateFetcher(ship));
    }
}; // class LSIButton

// --------------------------------------------------------------------
class OreMapButton extends Button {
    constructor(x, y, w, h, ore_map) {
        super(x, y, w, h, config.button_border,
            ["Ore detector: off", "Ore detector: on", "Ore detector: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg],
            0, true);
        this.ore_map = ore_map;
    }
    click_down() {
        if (this.ore_map == null) return;
        const active = !this.ore_map.active;
        this.ore_map.active = active;
        this.set_state(active ? 1 : 0);
    }
}; // class OreMapButton

// --------------------------------------------------------------------
class PortMapButton extends Button {
    constructor(x, y, w, h, port_map) {
        super(x, y, w, h, config.button_border,
            ["Port map off", "Port map on", "No port map"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            [config.color_btn_inactive_fg, config.color_btn_active_fg, config.color_btn_none_fg], 0, true);
        this.port_map = port_map;
    }
    click_down() {
        if (this.port_map == null) return;
        const active = !this.port_map.active;
        this.port_map.active = active;
        this.set_state(active ? 1 : 0);
    }
}; // class PortMapButton

// --------------------------------------------------------------------
class BankingButton extends Button {
    constructor(x, y, w, h, acct) {
        super(x, y, w, h, config.button_border,
            [""], [config.color_bank_bg], [config.color_bank_fg], 
            0, true, null, new BankingButtonTitleFetcher(acct));
        this.acct = acct;
    }
    draw(gfx) {
        if (this.title_fetcher != null)
            this.set_title(this.title_fetcher.get_title());
        super.draw(gfx);
    }
}; // class BankingButton

class BankingButtonTitleFetcher {
    constructor(acct) { this.acct = acct; }
    get_title() {
        let title = "Bank: $"+currency(this.acct.balance)+".";
        if (this.acct.loan != null)
            title += "\nDue: $"+this.acct.loan.payoff+" in "+dur_string(this.acct.loan.due-now());
        return title;
    }
};

// --------------------------------------------------------------------
class DirButton extends Button {
    constructor(x, y, w, h, border, title, bg, fg, keyname) {
        super(x, y, w, h, border, [title], [bg], [fg], 0, true);
        this.keyname = keyname;
    }
    click(down) {
        if (_game != null) _game.event_keystroke(this.keyname, down);
    }
    click_down() { this.click(true); }
    click_up() { this.click(false); }
}; // class DirButton

// --------------------------------------------------------------------
class NorthButton extends DirButton {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            "\u25b2", config.color_btn_dir, config.color_btn_dir_fg,
            "ArrowUp");
    }
}; // class NorthButton

// --------------------------------------------------------------------
class SouthButton extends DirButton {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            "\u25bc", config.color_btn_dir, config.color_btn_dir_fg, 
            "ArrowDown");
    }
}; // class SouthButton

// --------------------------------------------------------------------
class EastButton extends DirButton {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            "\u25b6", config.color_btn_dir, config.color_btn_dir_fg,
            "ArrowRight");
    }
}; // class EastButton

// --------------------------------------------------------------------
class WestButton extends DirButton {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.button_border,
            "\u25c0", config.color_btn_dir, config.color_btn_dir_fg,
            "ArrowLeft");
    }
}; // class WestButton

// --------------------------------------------------------------------
class DirPad extends Form {
    constructor(x, y, w, h) {
        super(x, y, w, h, config.color_dash_bg);
        this.empty = true;
    }
    draw(gfx) {
        if (this.w == 0 || this.h == 0) return;
        if (this.empty) {
            const yc = this.y + this.h/2;
            const dirw = this.w * 0.25;
            const dirh = dirw;
            this.add(new NorthButton(this.x + (this.w-dirw)/2,     yc-dirh*1.5, dirw, dirh));
            this.add(new SouthButton(this.x + (this.w-dirw)/2,     yc+dirh/2,   dirw, dirh));
            this.add(new EastButton (this.x + this.w/2 + dirw/2,   yc-dirh/2,   dirw, dirh));
            this.add(new WestButton (this.x + this.w/2 - dirw*1.5, yc-dirh/2,   dirw, dirh));
            this.empty = false;
        }
        super.draw(gfx);
    }
}; // class DirPad

// --------------------------------------------------------------------
class ResourceMap extends Drawable {
    constructor(x, y, w, h, range) {
        super(x, y, w, h);
        this.ship = null;
        this.objects = null;
        this.active = false;
        this.range2 = range/2;
    }
    install(ship, objects) {
        this.ship = ship;
        this.objects = objects;
    }
    draw(gfx) {
        const canvas2 = canvas_size("canvas2", this.w, this.h);
        const gfx2 = new Graphics(canvas2.getContext("2d"), this.h*0.25);
        const color = this.active ? config.color_resmap_bg : this.installed ? config.color_btn_inactive : config.color_btn_none;
        gfx2.draw_outlined_rect(0, 0, this.w, this.h, config.gauge_border, config.gauge_border, color, config.color_sky); 
        if (this.active) {
            gfx2.draw_rect(0, this.h/2 - 1, this.w, 2, config.color_sky);
            gfx2.draw_circle(this.w/2, this.h/2, 4, config.color_sky);
            gfx2.draw_circle(this.w/2, this.h/2, 3, config.color_ship);
            const resources = this.objects.get_list(this.ship.loc.x - this.range2, this.ship.loc.x + this.range2);
            for (const res of resources) {
                const x = (res.xpos - this.ship.loc.x + this.range2) * this.w / (this.range2*2);
                const y = this.h/2;
                this.draw_object(gfx2, res, x, y);
            }
            const rw = _game.w * this.w / (this.range2*2);
            const fh = 0.6;
            gfx2.draw_outline((this.w-rw)/2, this.h*(1-fh)/2, rw, this.h*fh, 1, 1, config.color_sky);
        }
        gfx.ctx.drawImage(canvas2, this.x, this.y);
    }
}; // class ResourceMap

// --------------------------------------------------------------------
class OreMap extends ResourceMap {
    constructor(x, y, w, h, range) {
        super(x, y, w, h, range);
    }
    draw_object(gfx, ore, x, y) {
        if (ore.mass == 0) return;
        const mass = ore.mass.toString();
        const mass_size = gfx.measure_text(mass);
        const bh = 5;
        gfx.draw_rect(x-1, y-bh, 2, bh*2, config.color_sky);
        gfx.draw_text(x-mass_size.width/2, y-bh-mass_size.height, mass, config.color_sky);
    }
}; // class OreMap

// --------------------------------------------------------------------
class PortMap extends ResourceMap {
    constructor(x, y, w, h, range) {
        super(x, y, w, h, range);
    }
    draw_object(gfx, port, x, y) {
        const ore_price = port.sell_ore_price().toString();
        const fuel_price = port.buy_fuel_price().toString();
        const ore_price_size = gfx.measure_text(ore_price);
        const fuel_price_size = gfx.measure_text(fuel_price);
        const bh = 5;
        gfx.draw_rect(x-1, y-bh, 2, bh*2, config.color_sky);
        gfx.draw_text(x-ore_price_size.width/2, y-bh-ore_price_size.height, ore_price, config.color_sky);
        gfx.draw_text(x-fuel_price_size.width/2, y+bh, fuel_price, config.color_sky);
    }
}; // class PortMap

// --------------------------------------------------------------------
class LiveStatus extends Drawable {
    constructor(x, y, w, h, acct) {
        super(x, y, w, h);
        this.acct = acct;
        this.message = "Welcome, pilot.\nYour ship is ready for liftoff.";
    }
    set_status(status) {
        this.message = status;
    }
    draw(gfx) {
        if (this.w == 0 || this.h == 0) return;
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, config.gauge_border, config.gauge_border, config.color_status_bg, config.color_sky); 
        const xindent = config.gauge_border + 4;
        gfx.draw_paragraph(this.message,
            this.x + xindent, this.y + config.gauge_border,
            this.w - 2*xindent, config.color_status_fg);
    }
}; // class LiveStatus

// --------------------------------------------------------------------
class Terrain extends Drawable {
    constructor(x, y, w, h) {
        super(x, y, w, h);
        this.max_elev = h-20; // FIXME
        this.peaks = [];
        this.zeropos = 0;
    }
    cover(sxpos, expos) {
        if (this.peaks.length == 0)
            this.peaks.push(config.min_elev);
        let elev = this.peaks[0];
        while (sxpos < this.zeropos) {
            elev = this.random_elevation(elev);
            this.peaks.unshift(elev);
            this.zeropos -= config.terr_step;
        }
        elev = this.peaks[this.peaks.length-1];
        while (this.zeropos + this.peaks.length * config.terr_step < expos) {
            elev = this.random_elevation(elev);
            this.peaks.push(elev);
        }
    }
    random_elevation(elev) {
        elev += (Math.random() * config.terr_step) - (config.terr_step/2);
        if (elev < config.min_elev) elev = config.min_elev;
        if (elev > this.max_elev) elev = this.max_elev;
        return elev;
    }
    index(xpos) {
        return Math.floor((xpos - this.zeropos) / config.terr_step);
    }
    elevation(xpos) {
this.cover(xpos-1000, xpos+1000); // FIXME
        const pi = this.index(xpos);
        const elev1 = this.peaks[pi];
        const elev2 = this.peaks[pi+1];
        const xpos1 = (pi * config.terr_step) + this.zeropos;
        const xpos2 = xpos1 + config.terr_step;
        const e = (elev2 - elev1) * (xpos - xpos1) / (xpos2 - xpos1);
        return elev1 + e;
    }
    draw(gfx, xpos, boty) {
        if (this.peaks.length == 0) return;
        const ctx = gfx.ctx;
        ctx.beginPath();
        const bot = this.y + this.h;
        let x = this.x;
        let xs = zmod(xpos, config.terr_step);
        if (xs > 0) x -= xs;
        let xlast = x;
        ctx.moveTo(x, bot);
        for (let pi = this.index(xpos);; ++pi) {
            if (pi >= this.peaks.length) 
                break;
            const y = this.peaks[pi];
            ctx.lineTo(x, bot - y + boty);
            xlast = x;
            if (x >= this.w) break;
            x += config.terr_step;
        }
        ctx.lineTo(xlast, bot); // drop to baseline at right
        ctx.fillStyle = config.color_terrain.jstring();
        ctx.fill();
    }
}; // class Terrain

// --------------------------------------------------------------------
class TerrObjects extends Drawable {
    constructor(x, y, w, h, terrain, screens_per, sep) {
        super(x, y, w, h);
        this.empty_extend = true;
        this.terrain = terrain;
        this.screens_per = screens_per;
        this.sep = sep;
        this.objects = [];
    }
    place(xpos) {
       const close = this.closest(xpos);
       if (close != null && Math.abs(close.xpos - xpos) < this.sep) return false;
       const mag = 10;
       const r = (randu(this.screens_per * this.w * mag));
       return (r  < mag);
    }
    cover(sxpos, expos) {
        if (this.empty_extend) {
            this.s_extend = this.e_extend = sxpos;
            this.empty_extend = false;
        }
        while (sxpos < this.s_extend) {
            this.s_extend--;
            if (this.place(this.s_extend))
                this.objects.unshift(this.new_object(this.s_extend));
        }
        while (expos > this.e_extend) {
            this.e_extend++;
            if (this.place(this.e_extend))
                this.objects.push(this.new_object(this.e_extend));
        }
    }
    index(xpos) {
        for (let i = 0; i < this.objects.length; ++i) {
            if (this.objects[i].xpos > xpos)
                return (i == 0) ? 0 : i-1;
        }
        return this.objects.length-1;
    }
    closest(xpos) {
        if (this.objects.length == 0) return null;
        let i = this.index(xpos);
        if (i < 0) return null;
        if (i < this.objects.length-1 &&
            Math.abs(this.objects[i].xpos - xpos) > Math.abs(this.objects[i+1].xpos - xpos))
            ++i;
        return this.objects[i];
    }
    get_list(sxpos, expos) {
        this.cover(sxpos, expos);
        let list = [];
        for (let i = this.index(sxpos); i >= 0 && i < this.objects.length && this.objects[i].xpos < expos; ++i) {
            list.push(this.objects[i]);
        }
        return list;
    }
    draw(gfx, xpos, boty) {
        if (this.objects.length == 0) return;
        for (let pi = this.index(xpos); pi < this.objects.length; ++pi) {
            const x = this.x + (this.objects[pi].xpos - xpos);
            if (x >= gfx.ctx.canvas.width) break;
            const y = this.y + this.h - this.terrain.elevation(this.objects[pi].xpos) + boty;
            this.objects[pi].draw(gfx, x, y);
        }
    }
}; // class TerrObjects

// --------------------------------------------------------------------
class Ports extends TerrObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.port_screens_per, config.port_sep);
    }
    new_object(xpos) {
        return new Port(xpos);
    }
    can_land(xpos) {
        const port = this.closest(xpos);
        if (port != null && Math.abs(port.xpos - xpos) <= config.port_land_max_dist)
            return port;
        return null;
    }
}; // class Ports

// --------------------------------------------------------------------
class Port {
    constructor(xpos) {
        this.xpos = xpos;
        this.name = this.random_name(xpos);
        this.fuel_price = 20 + Math.floor(Math.random() * 80);
        this.ore_price = 200 + Math.floor(Math.random() * 200);
    }
    buy_fuel_price() {
        return this.fuel_price;
    }
    sell_ore_price() {
        return this.ore_price;
    }
    random_name(xpos) {
        const names = [
            "Alpha", "Beta", "Gamma", "Delta", "Epsilon", "Sigma", "Tau", "Omega",
            "Molari", "Sinclair", "Lennier", "Garibladi",
            "Newton", "Gauss", "Euler", "Riemann", "Hilbert", "Abel", "Fermat", "Neumann",
            "Noether", "Hamilton", "Jacobi", "Cantor", "Descartes", "Weyl",
            "Cindy", 
        ];
        return names[zmod(nhash(xpos), names.length)];
    }
    draw(gfx, x, y) {
        gfx.draw_circle(x, y, config.port_land_max_dist, config.color_port);
        gfx.draw_text(x-30, y-40, this.name, config.color_port);
    }
}; // class Port

// --------------------------------------------------------------------
class OreDeposits extends TerrObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.deposit_screens_per, config.ore_sep);
    }
    new_object(xpos) {
        return new OreDeposit(this.ore_mass(xpos), xpos);
    }
    ore_mass(xpos) {
        const M = config.ore_mass_max - config.ore_mass_min;
        const k = nhash(xpos) % M;
return config.ore_mass_min + k;
        //return config.ore_mass_min + Math.floor((k*k*k) / (M*M));
    }
}; // class OreDeposits

// --------------------------------------------------------------------
class OreDeposit {
    constructor(mass, xpos) {
        this.mass = mass;
        this.xpos = xpos;
    }
    draw(gfx, x, y) {
        if (this.mass == 0) return;
        const r = Math.sqrt(this.mass) * 1.5; // FIXME
        gfx.draw_circle(x, y, r, config.color_ore);
    }
}; // class OreDeposit

// --------------------------------------------------------------------
class Billboard {
    constructor() {
    }
}; // class Billboard

// --------------------------------------------------------------------
class LiveView extends Drawable {
    constructor(x, y, w, h, ship, terrain, ports, deposits) {
        super(x, y, w, h);
        this.terrain = terrain;
        this.ports = ports;
        this.deposits = deposits;
        this.ship = ship;
    }
    draw(gfx) {
        const xpos = this.ship.loc.x - this.w/2;
        let boty = this.ship.loc.y - this.h + 50; // FIXME
        if (boty < 0) boty = 0;
        this.deposits.draw(gfx, xpos, boty);
        this.ports.draw(gfx, xpos, boty);
        this.terrain.draw(gfx, xpos, boty);
        this.ship.draw(gfx, xpos, boty);
        this.draw_grid(gfx, 0, boty);
        this.draw_grid(gfx, 1, boty);
    }
    draw_grid(gfx, left, boty) {
        const grid_color = config.color_sky.opposite();
        for (let yy = 0; ; yy += config.grid_step) {
            const y = this.h + boty - yy - config.grid_thick;
            if (y < 0) break;
            const label = yy.toString();
            const label_size = gfx.measure_text(label);
            const tick_x = left ? this.x : this.x + this.w - config.grid_len;
            const label_x = left ? tick_x + config.grid_len : tick_x - label_size.width;
            gfx.draw_rect(tick_x, y, config.grid_len, config.grid_thick, grid_color);
            gfx.draw_text(label_x, y-label_size.height/2, label, grid_color);
        }
    }
}; // class LiveView

// --------------------------------------------------------------------
class Account {
    constructor(deposit) {
        this.balance = deposit;
        this.loan = null;
        this.logs = [];
    }
    add_cash(amt, reason) {
        this.log(amt, reason);
        this.balance += amt;
        return this.balance;
    }
    remove_cash(amt, reason) {
        this.log(-amt, reason);
        if (amt > this.balance) {
            this.log(0, "overdrawn");
            amt = this.balance;
        }
        this.balance -= amt;
        return this.balance;
    }
    log(amt, reason) {
        const time = now();
        this.logs.push(time.toString()+" "+currency(this.balance)+" + "+currency(amt)+" "+reason);
    }
}; // class Account

// --------------------------------------------------------------------
class Loan {
    constructor(amt) {
        this.amt = amt;
        this.due = now() + this.term(amt);
        this.payoff = Math.floor(amt * (1+this.interest(amt)));
    }
    term(amt) {
        return 5*60*1000;
    }
    interest(amt) {
        return 0.10; ///FIXME
    }
    check_due(acct) {
        if (now() < this.due)
            return 0;
    ///@@@
    }
}; // class Loan

// --------------------------------------------------------------------
class MassiveObject extends Drawable {
    constructor(x, y, w, h, xpos, ypos, mass, time) {
        super(x, y, w, h);
        this.mass = mass;
        this.loc = new Vector(xpos, ypos);
        this.vel = new Vector(0,0);
        this.acc = new Vector(0,0);
        this.time = time;
    }
    accelerate(xforce, yforce) {
        this.acc = new Vector(xforce / this.mass, yforce / this.mass);
    }
    below_terrain(terrain) { // FIXME
        const elev = terrain.elevation(this.loc.x);
        return this.loc.y < elev;
    }
    stop() {
        this.vel.x = this.vel.y = 0;
        this.acc.x = this.acc.y = 0;
    }
    update(time) {
        const dt = time - this.time;
        this.loc.add(this.vel.mul(dt));
        this.vel.add(this.acc.mul(dt));
        this.time = time;
    }
}; // class MassiveObject

// --------------------------------------------------------------------
class Ship extends MassiveObject {
    constructor(x, y, w, h, xpos, ypos) {
        super(x, y, w, h, xpos, ypos, config.ship_mass, now());
        this.bot_thrust = 0;
        this.side_thrust = 0;
        this.cargo = 0;
        this.max_cargo = config.ship_max_cargo;
        this.fuel = 0;
        this.max_fuel = config.max_fuel;
        this.flying = false;
        this.inport = null;
    }
    load_ore(deposit) {
        if (deposit + this.cargo > this.max_cargo)
            deposit = this.max_cargo - this.cargo;
        this.cargo += deposit;
        this.mass += deposit;
        return deposit;
    }
    unload_ore() {
        const cargo = this.cargo;
        this.mass -= cargo;
        this.cargo = 0;
        return cargo;
    }
    add_fuel(fuel) {
        if (fuel + this.fuel > this.max_fuel)
            fuel = this.max_fuel - this.fuel;
        this.fuel += fuel;
        return fuel;
    }
    use_fuel(fuel) {
        this.fuel -= fuel;
        if (this.fuel < 0) {
            this.fuel = 0;
            _game.game_over("Your ship ran out of fuel!");
        }
    }
    set_bot_thrust(on, supercharge = false) {
        if (!this.flying && on) this.liftoff();
        this.bot_thrust = supercharge ? config.ship_bot_thrust*3 : on ? config.ship_bot_thrust : 0;
    }
    set_side_thrust(left, on) {
        if (!this.flying) return;
        this.side_thrust = !on ? 0 : left ? config.ship_side_thrust : -config.ship_side_thrust;
    }
    liftoff() {
        this.flying = true;
        this.vel.y = config.liftoff_vel;
        this.use_fuel(config.liftoff_fuel);
        this.set_status("Lift-off!");
    }
    land(terrain) {
        this.flying = false;
        this.bot_thrust = this.side_thrust = 0;
        this.stop();
        this.loc.y = terrain.elevation(this.loc.x);
        this.set_status("Landed safely.");
    }
    enter_port(port) {
        this.inport = port;
        this.set_status("In port "+port.name+".");
    }
    exit_port() {
        this.set_status("Left port "+this.inport.name+".");
        this.inport = null;
    }
    prospect(deposits) {
        const deposit = deposits.closest(this.loc.x);
        if (deposit == null || Math.abs(deposit.xpos - this.loc.x) > config.deposit_dig_max_dist) {
            this.set_status("No ore deposits found here.");
            return 0;
        }
        const loaded = this.load_ore(deposit.mass);
        deposit.mass -= loaded;
        if (deposit.mass == 0)
            this.set_status("Loaded "+loaded.toString()+" tons of ore!");
        else if (loaded == 0)
            this.set_status("Ship is full; cannot load any more ore.");
        else
            this.set_status("Loaded "+loaded.toString()+" tons of ore. Leaving "+deposit.mass.toString()+" tons because ship is full.");
        return loaded;
    }
    update(time) {
        const dt = time - this.time;
        super.update(time);
        const fuel_used = (this.bot_thrust + Math.abs(this.side_thrust)) * config.fuel_per_thrust * dt;
        this.use_fuel(fuel_used);
        if (this.flying)
            this.accelerate(this.side_thrust, this.bot_thrust - config.gravity);
    }
    set_status(msg) {
        _game.set_status(msg); // FIXME
    }
    draw(gfx, xpos, boty) {
        const x = this.x + this.loc.x - xpos;
        const y = this.y + this.h - this.loc.y + boty;
        const r = this.w * 0.02;
        this.draw_body(gfx, x, y, r);
        if (this.bot_thrust > 0) this.draw_bot_thrust(gfx, x, y, r);
        if (this.side_thrust < 0) this.draw_side_thrust(gfx, x, y, r, false);
        if (this.side_thrust > 0) this.draw_side_thrust(gfx, x, y, r, true);
    }
    draw_body(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_ship.jstring();
        ctx.beginPath();
        const H = r*.2;
        const W = r*.4;
        ctx.moveTo(x, y);
        ctx.lineTo(x-W, y+H);
        ctx.lineTo(x, y-r);
        ctx.lineTo(x+W, y+H);
        ctx.fill();
    }
    draw_bot_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        const W = r*.2;
        const L = r*1.7;
        const D = r*0.1;
        ctx.moveTo(x+W, y+D);
        ctx.lineTo(x, y+L); // tail
        ctx.lineTo(x-W, y+D);
        ctx.fill();
    }
    draw_side_thrust(gfx, x, y, r, left) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        var W = r*.15;
        var L = r*2.0;
        var D = r*0.5;
        if (left) { D = -D; L = -L; }
        y -= r*.05;
        ctx.moveTo(x+D, y-W);
        ctx.lineTo(x+L, y); // tail
        ctx.lineTo(x+D, y+W);
        ctx.fill();
    }
}; // class Ship

class ShipFuelFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.fuel; }
};

class ShipCargoFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.cargo; }
};

class ShipAltitudeFetcher {
    constructor(ship, terrain) { this.ship = ship; this.terrain = terrain; }
    gauge_value() { return this.ship.loc.y - this.terrain.elevation(this.ship.loc.x); }
};

class ShipFlyingStateFetcher {
    constructor(ship) { this.ship = ship; }
    button_state() { return this.ship.flying ? 1 : 0; }
};

// --------------------------------------------------------------------
class DashClock extends Drawable {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
    draw(gfx) {
        const time = new Date();
        const sec = time.getSeconds();
        const min = time.getMinutes();
        const hr = time.getHours();
        const time_str = hr.toString()+":"+min.toString().padStart(2,"0")+":"+sec.toString().padStart(2,"0");
        const time_size = gfx.measure_text(time_str);
        const b = 2;
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, b, b, config.color_clock_bg, config.color_clock_border);
        gfx.draw_centered_text(this.x, this.y+(this.h-time_size.height)/2, this.w, time_str, config.color_clock_fg);
    }
}; // class DashClock

// --------------------------------------------------------------------
class Dash extends Form {
    constructor(x, y, w, h, ship, acct, terrain) {
        super(x, y, w, h, config.color_dash_bg);
        const row_sp = h*.05;
        const col_sp = w*.01;
        const btn_h = (h - 4*row_sp) / 3;
        this.layout = new Layout(x, y, w, h, this,
            3, [btn_h, btn_h, btn_h],
            7, [w*.05, w*.05, w*.05, w*.12, w*.15, w*.15, -1],
            row_sp, col_sp);
        this.layout.add(2, 0, this.alt_gauge = new AltitudeGauge(0,0,0,0, ship, terrain), 3);
        this.layout.add(2, 1, this.ore_gauge = new OreGauge(0,0,0,0, ship), 3);
        this.layout.add(2, 2, this.fuel_gauge = new FuelGauge(0,0,0,0, ship), 3);
        this.layout.add(0, 6, this.ore_map = new OreMap(0,0,0,0, config.resmap_range_mult*w));
        this.layout.add(1, 6, this.port_map = new PortMap(0,0,0,0, config.resmap_range_mult*w));
        this.layout.add(2, 6, this.live_status = new LiveStatus(0,0,0,0, acct));
        this.layout.add(0, 4, this.add(new ScoopButton(0,0,0,0)));
        this.layout.add(1, 4, this.add(new LSIButton(0,0,0,0)));
        this.layout.add(2, 4, this.add(new FlyingButton(0,0,0,0, ship)));
        this.layout.add(0, 5, this.add(new OreMapButton(0,0,0,0, this.ore_map)));
        this.layout.add(1, 5, this.add(new PortMapButton(0,0,0,0, this.port_map)));
        this.layout.add(2, 5, this.add(new BankingButton(0,0,0,0, acct)));
        this.layout.add(1, 3, this.add(new DirPad(0,0,0,0)), 2);
        this.layout.add(2, 3, this.add(new DashClock(0,0,0,0)));
        this.need_layout = true;
    }
    set_status(status) {
        ///this.live_status.set_status(status);
    }
    draw(gfx) {
        if (this.need_layout) {
            this.layout.layout(gfx);
            this.need_layout = false;
        }
        super.draw(gfx);
        gfx.draw_rect(this.x, this.y, this.w, this.h*.015, config.color_sky);
        this.alt_gauge.draw(gfx);
        this.ore_gauge.draw(gfx);
        this.fuel_gauge.draw(gfx);
        this.ore_map.draw(gfx);
        this.port_map.draw(gfx);
        this.live_status.draw(gfx);
    }
}; // class Dash

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.acct = new Account(10000);
        const canvas = gfx.ctx.canvas;
        const cw = canvas.width;
        const ch = canvas.height;
        this.x = 0;
        this.y = 0;
        this.w = cw;
        this.h = ch;
        const dash_h = Math.floor(ch*.35);
        const dash_y = ch - dash_h;
        const view_y = 0;
        const view_h = dash_y - view_y;

        this.playing = true;
        const xb = cw*.05;
        const yb = 0;
        this.msgrect = { x:xb, y:yb, w:cw-2*xb, h:view_h*config.menu_yfrac };
        this.menurect = this.msgrect;
        this.terrain = new Terrain(0, view_y, cw, view_h);
        this.ports = new Ports(0, view_y, cw, view_h, this.terrain);
        this.deposits = new OreDeposits(0, view_y, cw, view_h, this.terrain);
        const shipxpos = 1000; // FIXME
        const shipypos = this.terrain.elevation(shipxpos);
        this.ship = new Ship(0, view_y, cw, view_h, shipxpos, shipypos);
this.ship.add_fuel(this.ship.max_fuel/3);
        this.dash = new Dash(0, dash_y, cw, dash_h, this.ship, this.acct, this.terrain);
this.dash.ore_map.install(this.ship, this.deposits); // OreMap
this.dash.port_map.install(this.ship, this.ports); // PortMap
        this.view = new LiveView(0, view_y, cw, view_h, this.ship, this.terrain, this.ports, this.deposits);
        this.status = null;
        this.message = null;
        this.forms = [ this.dash ];
        this.debugrid = false;
    }
    exit_port() {
        this.ship.exit_port();
    }
    pop_form() {
        this.forms.pop();
        for (const form of this.forms) {
            form.update_form();
        }
    }
    run() {
        if (!this.playing) return;
        const time = now();
        const ship = this.ship;
        const was_flying = ship.flying;
        ship.update(time);
        if (ship.flying && ship.below_terrain(this.terrain)) {
            if (ship.vel.norm2() > config.crash_vel2) {
                this.game_over("You crashed!");
            } else {
                ship.land(this.terrain);
            }
        }
        this.draw();
        if (ship.flying && !was_flying) { // liftoff
            if (ship.inport != null) {
                // FIXME wait this can't really happen, right? ship just spontaneously takes off while in the menu?
                this.exit_port();
            }
        } else if (!ship.flying && was_flying) { // landing
            const land_port = this.view.ports.can_land(ship.loc.x);
            if (land_port != null) {
                ship.enter_port(land_port);
                const r = this.menurect;
                const menu = new PortMenu(r.x, r.y, r.w, r.h, land_port, this.acct);
                this.forms.push(menu.init());
            } else {
                const loaded = ship.prospect(this.deposits);
            }
        }
    }
    set_status(status) {
        this.dash.set_status(status);
    }
    draw() {
        const sxpos = this.ship.loc.x - this.terrain.w;
        const expos = this.ship.loc.x + this.terrain.w;
        this.terrain.cover(sxpos, expos);
        this.ports.cover(sxpos, expos);
        this.deposits.cover(sxpos, expos);
        this.gfx.clear(config.color_sky);
        this.view.draw(this.gfx);
        for (let i = 0; i < this.forms.length; ++i) {
            this.forms[i].draw(this.gfx);
        }
        this.draw_message();
        if (this.debugrid) this.draw_debugrid(this.gfx);
    }
    static _event_keydown(e) {
        if (_game != null) _game.event_keystroke(e.key, true);
    }
    static _event_keyup(e) {
        if (_game != null) _game.event_keystroke(e.key, false);
    }
    static _event_mousedown(e) {
        if (_game != null) _game.event_mouse(true, e.offsetX, e.offsetY);
    }
    static _event_mouseup(e) {
        if (_game != null) _game.event_mouse(false, e.offsetX, e.offsetY);
    }
    event_keystroke(key, down) {
        switch (key) {
        case 'ArrowDown':
            this.ship.set_bot_thrust(down);
            break;
        case 'ArrowUp':
            this.ship.set_bot_thrust(down, down);
            break;
        case 'ArrowRight':
            this.ship.set_side_thrust(false, down);
            break;
        case 'ArrowLeft':
            this.ship.set_side_thrust(true, down);
            break;
        case 'G':
            if (down) this.debugrid = !this.debugrid;
            break;
        }
    }
    event_mouse(down, x, y) {
        if (!down) _held = null;
        if (this.forms.length == 0) return;
        this.forms[this.forms.length-1].mouse(down, x, y);
    }
    game_over(msg) {
        this.message = "Game over: "+msg;
        this.draw();
        this.playing = false;
    }
    draw_message() {
        if (this.message == null) return;
        const b = 5;
        this.gfx.draw_outlined_rect(this.msgrect.x, this.msgrect.y, this.msgrect.w, this.msgrect.h, b, b, config.color_msg_bg, config.color_msg_border);
        const y = this.msgrect.y + (this.msgrect.h - this.gfx.font_height) / 2;
        this.gfx.draw_centered_text(this.msgrect.x, y, this.msgrect.w, this.message, config.color_msg_fg);
    }
    draw_debugrid(gfx) {
        const canvas = gfx.ctx.canvas;
        const step = 100;
        const minor = 10;
        const major = 500;
        const gw = 8;
        for (let x = 0; x < canvas.width; x += step) {
            const thick = (x % major) ? 1 : 3;
            gfx.draw_rect(x-thick/2, 0, thick, canvas.height, config.color_debugrid);
        }
        for (let y = 0; y < canvas.height; y += step) {
            const thick = (y % major) ? 1 : 3;
            gfx.draw_rect(0,y-thick/2,canvas.width,thick, config.color_debugrid);
        }
        for (let x = 0; x < canvas.width; x += minor)
            gfx.draw_rect(x,(canvas.height-gw)/2,1,gw, config.color_debugrid);
        for (let y = 0; y < canvas.height; y += minor)
            gfx.draw_rect((canvas.width-gw)/2,y,gw,1, config.color_debugrid);
    }
}; // class Game

// --------------------------------------------------------------------

function now() {
    return performance.now();
}

function dur_string(dur) {
    dur = Math.floor(dur);
    const ms  = dur % 1000;  dur = Math.floor(dur/1000);
    const sec = dur % 60;  dur = Math.floor(dur/60);
    const min = dur % 60;  dur = Math.floor(dur/60);
    const hr  = dur % 24;  ///dur = Math.floor(dur/24);
    let str = (hr == 0) ? min.toString() : hr.toString()+":"+padnum(min,2,10);
    str += ":"+padnum(sec,2,10);
    return str;
}

function run_game() {
    if (_game != null) _game.run();
    window.requestAnimationFrame(run_game);
}

function munge_config() {
    for (const [key,value] of Object.entries(config)) {
        if (key.substr(0,6) == "color_")
            config[key] = new Color(config[key]);
    }
}

function el(name) {
    return document.getElementById(name);
}

function currency(amt) {
    let r = "";
    let sep = 3;
    let a = amt.toString();
    let i = a.length-sep;
    for (; i > 0; i -= sep) {
        r = "," + a.substr(i,sep) + r;
    }
    r = a.substr(0,sep+i) + r;
    return r;
}

function padnum(num, len, radix) {
    return Math.floor(num).toString(radix).padStart(len,"0");
}
function hex2(num) { return padnum(num, 2, 16); }

function nhash(n) {
    n = n*n;
    return (n >> 8) & 0xffff;
}

function zmod(x, m) {
    if (x >= 0) return x % m;
    let r = (-x) % m;
    if (r > 0) r = m - r;
    return r;
}

function randu(n) {
    return Math.floor(Math.random() * n);
}

function canvas_size(name, w, h) {
    const canvas = el(name);
    canvas.width = w;
    canvas.height = h;
    return canvas;
}

function canvas_resize() {
    const s = 20;
    return canvas_size("canvas", window.innerWidth - s, window.innerHeight - s);
}

function main() {
    munge_config();
    const canvas = canvas_resize();
    const gfx = new Graphics(canvas.getContext("2d"), canvas.height*.028);
    _game = new Game(gfx);
    document.addEventListener('keyup', Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    document.addEventListener('mousedown', Game._event_mousedown);
    document.addEventListener('mouseup', Game._event_mouseup);
    window.addEventListener('resize', canvas_resize, false);
    run_game();
}

</script>
</body>
</html>
