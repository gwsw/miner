<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Lunar Miner</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1"></canvas>
<script>

var config = {
    button_border          : 5,
    crit_fuel              : 2,
    gauge_border           : 3,
    meter_per_pix          : 10,
    view_xstep_m           : 50,
    view_width_m           : 1500,
    low_fuel               : 10,
    max_fuel               : 100,
    ship_bot_thrust        : 10,
    ship_mass              : 50,
    ship_max_cargo         : 500,

    color_btn_active       : new Color("10ff40"),
    color_btn_inactive     : new Color("c08010"),
    color_btn_none         : new Color("808080"),
    color_btn_text         : new Color("ffffff"),
    color_fuel             : new Color("10d040"),
    color_gauge_bg         : new Color("e0e0e0"),
    color_gauge_text       : new Color("000000"),
    color_land             : new Color("707070"),
    color_ore              : new Color("c000c0"),
    color_sky              : new Color("000000"),
    color_ship             : new Color("10ffff"),
    color_thrust           : new Color("ff3010"),
};

// --------------------------------------------------------------------
class Color {
    constructor(hex) {
        this.hex_str = hex;
    }
    hex() {
        return this.hex_str;
    }
    jstring() {
        return "#" + this.hex_str;
    }
    get_comp(comp) {
        return parseInt(this.hex_str.substr(comp*2, 2), 16);
    }
    adj(comp, incr) {
        let val = this.get_comp(comp) + incr;
        if (val < 0) val = 0;
        if (val > 255) val = 255;
        const ci = comp*2;
        return new Color(this.hex_str.substr(0,ci) + hex2(val) + this.hex_str.substr(ci+2));
    }
    darker(mult) {
        return new Color(hex2(this.get_comp(0)*mult) + hex2(this.get_comp(1)*mult) + hex2(this.get_comp(2)*mult));
    }
    opposite() {
        return new Color(hex2(255-this.get_comp(0)) + hex2(255-this.get_comp(1)) + hex2(255-this.get_comp(2)));
    }
    contrast() {
        const bright = this.get_comp(0) + this.get_comp(1) + this.get_comp(2);
        return new Color((bright > (3*128)) ? "000000" : "ffffff");
    }
};

// --------------------------------------------------------------------
class Vector {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
    }
    mul(num) {
        return new Vector(this.x*num, this.y*num);
    }
    norm2() {
        return this.x*this.x + this.y*this.y;
    }
}; // class Geom

// --------------------------------------------------------------------
class Graphics {
    constructor(ctx) {
        this.ctx = ctx;
        const text_size = ctx.measureText("M");
        this.font_height = text_size.width * 1.5; // FIXME
    }
    function draw_rect(x, y, w, h, color) {
        if (color != undefined) this.ctx.fillStyle = color.jstring();
        this.ctx.fillRect(x, y, w, h);
    }
    draw_centered_rect(cx, cy, w, h, color) {
        this.draw_rect(cx - w/2, cy - h/2, w, h, color);
    }
    draw_outline(x, y, w, h, xb, yb, color) {
        this.draw_rect(x,      y,       w-xb,   yb,   color);
        this.draw_rect(x+w-xb, y,       xb,     h-yb, color);
        this.draw_rect(x+xb,   y+h-yb,  w-xb,   yb,   color);
        this.draw_rect(x,      y+yb,    xb,     h-yb, color);
    }
    draw_centered_outline(cx, cy, w, h, xb, yb, color) {
        this.draw_outline(cx - w/2, cy - h/2, w, h, xb, yb, color);
    }
    draw_circle(x, y, r, color) {
        this.ctx.beginPath();
        this.ctx.fillStyle = color.jstring();
        this.ctx.arc(x, y, r, 0, 2*Math.PI);
        this.ctx.fill();
    }
    draw_text(x, y, text, color) {
        this.ctx.fillStyle = color.jstring();
        this.ctx.fillText(text, x, y);
    }
    measure_text(text) {
        const text_size = this.ctx.measureText(text);
        return { width: text_size.width, height: this.font_height };
    }
    draw_centered_text(x, y, w, text, color) {
        const text_size = this.measure_text(text);
        const nx = x + (w - text_size.width) / 2;
        if (nx > x) x = nx;
        draw_text(x, y, text, color);
        return text_size;
    }
}; // class Graphics

// --------------------------------------------------------------------
class UserInput {
    constructor() {
    }
    getkey() {
    }
}; // class UserInput

// --------------------------------------------------------------------
class DashClock {
    constructor() {
    }
}; // class DashClock

// --------------------------------------------------------------------
class Gauge {
    constructor(title, x, y, w, h, color, max_value, low_value, crit_value) {
        this.title = title;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;
        this.max_value = max_value;
        this.low_value = low_value;
        this.crit_value = crit_value;
        this.value = 0;
    }
    set_value(value) {
        value = Math.min(value, this.max_value);
        this.value = value;
    }
    get_value(value) {
        return this.value;
    }
    draw(gfx) {
        let title_size = draw_centered_text(this.x, this.y, this.w, this.title);
        const gh = this.h - title_size.height;
        const gb = config.gauge_border;
        const inh = gh - 2*gb;
        const inw = this.w - 2*gb;
        const barh = inh * this.value / this.max_value;
        const bot = this.y + this.h;
        const value_text = this.value.toString();
        const value_text_size = gfx.measure_text(value_text);
        gfx.draw_outline(this.x, this.y+title_size.height, this.w, gh, gb, gb, config.color_gauge_bg);
        gfx.draw_rect(this.x+gb, bot-gb-barh, inw, barh, this.color);
        gfx.draw_centered_text(this.x, bot-value_text_size.height, this.w, value_text, config.color_gauge_text);
    }
}; // class Gauge

// --------------------------------------------------------------------
class FuelGauge extends Gauge {
    constructor(x, y, w, h) {
        super("Fuel", x, y, w, h, config.fuel_color, config.max_fuel, config.low_fuel, config.crit_fuel);
    }
}; // class FuelGauge

// --------------------------------------------------------------------
class OreGauge extends Gauge {
    constructor(x, y, w, h) {
        super("Cargo", x, y, w, h, config.ore_color, ship.max_cargo, 0, 0);
    }
}; // class OreGauge

// --------------------------------------------------------------------
class AltGauge extends Gauge {
    constructor(x, y, w, h) {
        super("Alt", x, y, w, h, config.land_color, config.max_alt, 0, 0);
    }
}; // class AltGauge 

// --------------------------------------------------------------------
class Button {
    constructor(state_titles, state_colors, state, x, y, w, h, click_handler) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.state_titles = state_titles;
        this.state_colors = state_colors;
        this.state = state;
        this.click_handler = click_handler;
    }
    set_state(state) {
        this.state = state;
    }
    draw(gfx) {
        let bb = config.button_border;
        gfx.draw_outline(this.x, this.y, this.w, this.h, bb, bb, this.state_colors[this.state]);
        let cy = y + h/2; // FIXME
        gfx.draw_centered_text(x, cy, w, this.state_titles[this.state], config.color_btn_text);
    }
    click() {
        this.click_handler();
    }
}; // class Button

// --------------------------------------------------------------------
class Menu {
    constructor() {
    }
}; // class Menu

// --------------------------------------------------------------------
class PortMenu {
    constructor() {
    }
}; // class PortMenu

// --------------------------------------------------------------------
class Store {
constructor() {
}
}; // class Store

// --------------------------------------------------------------------
class StoreMenu {
    constructor() {
    }
}; // class StoreMenu

// --------------------------------------------------------------------
class ScoopButton extends Button {
    constructor(x, y, w, h) {
        super.Button(["Ore scoop: off", "Ore scoop: on", "Ore scoop: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, click_ore_scoop);
    }
}; // class ScoopButton

// --------------------------------------------------------------------
class LSIButton extends Button {
    constructor(x, y, w, h) {
        super.Button(["LSI: off", "LSI: on"],
            [config.color_btn_inactive, config.color_btn_active],
            0, x, y, w, h,  click_lsi);
    }
}; // class LSIButton

// --------------------------------------------------------------------
class OreDetectorButton {
    constructor(x, y, w, h) {
        super.Button(["Ore detector: off", "Ore detector: on", "Ore detector: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, click_ore_detector);
    }
}; // class OreDetectorButton

// --------------------------------------------------------------------
class PortMapButton {
    constructor(x, y, w, h) {
        super.Button(["Port map: off", "Port map: on", "Port map: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, click_port_map);
    }
}; // class PortMapButton

// --------------------------------------------------------------------
class LiveStatusButton {
    constructor(x, y, w, h) {
        super.Button(["Status"], [config.color_btn_none], 
            0, x, y, w, h, click_live_status);
    }
}; // class LiveStatusButton

// --------------------------------------------------------------------
class ResourceMap {
    constructor() {
    }
}; // class ResourceMap

// --------------------------------------------------------------------
class OreDetector extends ResourceMap {
    constructor() {
    }
}; // class OreDetector

// --------------------------------------------------------------------
class PortMap extends ResourceMap {
    constructor() {
    }
}; // class PortMap

// --------------------------------------------------------------------
class LiveStatus {
    constructor() {
    }
}; // class LiveStatus

// --------------------------------------------------------------------
class LiveView {
    constructor(land, offset) {
        this.land = land;
        this.offset = offset;
        this.width = ???
    }
    set_offset(offset) {
        this.offset = offset;
    }
    draw(gfx) {
        const offset = this.ship.pos - this.width / 2;
        user.land.draw(gfx, offset);
        user.ship.draw(gfx, this.offset);
    }
}; // class LiveView

// --------------------------------------------------------------------
class Landscape {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.peaks = [];
        this.chunks = [];
        this.ports = [];
        this.extend(1000);
    }
    extend(pos) {
        if (this.peaks.length == 0);
            this.peaks.push(0);
        let alt = this.peaks[this.peaks-1];
        while (this.peaks.length < pos) {
            alt += (Math.random() * config.alt_step) - (config.alt_step/2);
            if (alt < 0) alt = 0;
            this.peaks.push(alt);
            if (this.place_chunk(pos))
                this.chunks.push(new OreChunk(??mass, pos));
            if (this.place_port(pos))
                this.ports.push(new Port(pos));
        }
    }
    chunk_index(pos) {
        for (let i = 0; i < this.chunks.length; ++i) {
            if (this.chunks[i].pos > pos)
                return (i == 0) ? 0 : i-1;
        }
        return this.chunks.length-1;
    }
    get_peak(n) {
        this.extend(n + 100); // FIXME
        return this.peaks[n];
    }
    draw(gfx, pos) {
        this.draw_ports(gfx, pos);
        this.draw_land(gfx, pos);
        this.draw_chunks(gfx, pos);
    }
    draw_land(gfx, pos) {
        if (this.peaks.length == 0) return;
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_land.jstring();
        ctx.beginPath();
        const bot = this.y + this.h;
        let xlast = this.x;
        ctx.moveTo(x, bot);
        for (let pi = this.peak_index(pos); pi < this.peaks.length(); ++pi) {
            const x = this.x + pi * config.view_xstep_m / config.meter_per_pix;
            if (x >= gfx.width) break;
            const y = this.peaks[pi] / config.meter_per_pix * config.view_xstep_m;
            ctx.lineTo(x, bot - y);
            xlast = x;
        }
        ctx.lineTo(xlast, bot);
        ctx.fill();
    }
    draw_chunks(gfx, pos) {
        for (ci = chunk_index(pos); this.chunks[ci].pos < gfx.width; ++ci) {
            const x = ...
            const y = ...
            this.chunks[ci].draw(gfx, x, y);
        }
    }
    draw_ports(gfx, pos) {
        for (pi = port_index(pos); this.ports[pi].pos < gfx.width; ++pi) {
            const x = 
            const y = ...
            this.ports[pi].draw(gfx, x, y);
        }
    }
}; // class Landscape


// --------------------------------------------------------------------
class OreChunk {
    constructor(mass, pos) {
        this.mass = mass;
        this.pos = pos;
    }
    draw(gfx, x, y) {
        const r = Math.sqrt(this.mass) * .1; // FIXME
        gfx.draw_circle(x, y, r, config.color_ore);
    }
}; // class OreChunk

// --------------------------------------------------------------------
class Port {
    constructor(pos) {
        this.pos = pos;
        this.name = ???;
    }
    draw(gfx) {
        const x = 
    }
}; // class Port

// --------------------------------------------------------------------
class Billboard {
    constructor() {
    }
}; // class Billboard

// --------------------------------------------------------------------
class Account {
    constructor(deposit) {
        this.balance = deposit;
    }
    add_cash(amt) {
        this.balance += amt;
    }
    sell_ore(ship, mass, dollars_per_ton, acct) {
        const cargo = ship.unload_ore();
        const price = dollars_per_ton * mass;
        this.add_cash(price);
    }
}; // class Account

// --------------------------------------------------------------------
class Loan {
    constructor() {
    }
}; // class Loan

// --------------------------------------------------------------------
class MassiveObject {
    constructor(mass, pos, time) {
        this.mass = mass;
        this.pos = pos;
        this.vel = new Vector(0,0);
        this.acc = new Vector(0,0);
        this.time = time;
    }
    accelerate(xforce, yforce) {
        this.acc = new Vector(xforce / this.mass, yforce / this.mass);
    }
    intersects_land(land) {
        return false; // FIXME
    }
    update(time) {
        const dt = time - this.time;
        this.pos.add(this.vel.mul(dt));
        this.vel.add(this.acc.mul(dt));
        this.time = time;
    }
}; // class MassiveObject

// --------------------------------------------------------------------
class Ship extends MassiveObject {
    constructor(pos) {
        super(config.ship_mass, pos, now());
        this.pos = pos;
        this.bot_thrust = 0;
        this.side_thrust = 0;
        this.cargo = 0;
        this.max_cargo = config.ship_max_cargo;
        this.fuel = 0;
        this.flying = false;
    }
    load_ore(chunk) {
        ship.cargo = Math.min(ship.cargo + chunk.mass, ship.max_cargo);
    }
    unload_ore() {
        const cargo = ship.cargo;
        ship.cargo = 0;
        return cargo;
    }
    add_fuel(fuel) {
        this.fuel += fuel;
    }
    set_thrust(thruster, on) {
        if (thruster == this.BOTTOM_THRUSTER()) {
            this.bot_thrust = on ? config.ship_bot_thrust : 0;
        } else if (thruster == this.RIGHT_THRUSTER()) {
            this.side_thrust = on ? config.ship_side_thrust : 0;
        } else if (thruster == this.LEFT_THRUSTER()) {
            this.side_thrust = on ? -config.ship_side_thrust : 0;
        }
    }
    land(port) {
        this.inport = port;
    }
    liftoff() {
        this.inport = null;
    }
    flying() {
        return !this.inport;
    }
    update(time) {
        const dt = time - this.time;
        super(time);
        const fuel_used = (this.bot_thrust + Math.abs(this.side_thrust)) * config.fuel_per_thrust;
        this.fuel -= fuel_used;
        if (this.fuel < 0) {
            this.fuel = 0;
            game_over("ran out of fuel");
        }
        this.accelerate(this.bot_thrust, this.side_thrust);
        if (this.intersects_land(user.land)) {
            if (this.vel.norm2() > config.crash_vel2) {
                game_over("crashed");
            }
        }
    }
    draw(gfx, x, y) {
        const r = ctx.canvas.width * 0.01;
        this.draw_body(gfx, x, y, r);
        if (this.bot_thrust > 0) this.draw_bot_thrust(gfx, x, y, r);
        if (this.side_thrust > 0) this.draw_right_thrust(gfx, x, y, r);
        if (this.side_thrust < 0) this.draw_left_thrust(gfx, x, y, r);
    }
    draw_body(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_ship.jstring();
        ctx.beginPath();
        ctx.moveTo(x, y-r);
        ctx.lineTo(x-r/2, y+r);
        ctx.lineTo(x, y+r/2);
        ctx.lineTo(x+r/2, y+r);
        ctx.fill();
    }
    draw_bot_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x+r/2, y+1.5*r);
        ctx.lineTo(x, y+3*r); // tail
        ctx.lineTo(x-r/2, y+1.5*r);
        ctx.fill();
    }
    draw_left_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x-1.5*r, y-r/2);
        ctx.lineTo(x-3*r, y); // tail
        ctx.lineTo(x-1.5*r, y+r/2);
        ctx.fill();
    }
    draw_right_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x+1.5*r, y-r/2);
        ctx.lineTo(x+3*r, y); // tail
        ctx.lineTo(x+1.5*r, y+r/2);
        ctx.fill();
    }
}; // class Ship

// --------------------------------------------------------------------
class Dash {
    constructor(ship, x, y, w, h) {
        const b   = w * .01;
        const p1w = w * .15;
        const p2w = w * .20;
        const p3w = w * .10;
        const p4w = w - (p1w + p2w + 2*p3w + 4*b);
        const p1x = x;
        const p2x = p1x + p1w;
        const p3x = p2x + p2w;
        const p4x = p3x + p3w;
        const gw = (p2w - 4*b) / 3;
        const gh = h - 2*b;
        const b3w = (p3w-b) / 2;
        const b3h = (h-4*b) / 3;
        const p3x2 = p3x + b3w + b;
        const p3y2 = y+b+b3h+b;
        const p3y3 = p3y2+b3h+b;
        this.alt_gauge = new AltGauge(p2x, y+b, gw, gh);
        this.ore_gauge = new OreGauge(p2x+gw+b, y+b, gw, gh);
        this.fuel_gauge = new FuelGauge(p2x+2*(gw+b), y+b, gw, gh);
        this.scoop_btn = new ScoopButton(p3x, y+b, b3w, b3h);
        this.lsi_btn = new LSIButton(p3x, p3y2, b3w, b3h);
        this.fly_btn = new FlyButton(p3x, p3y3, b3w, b3h);
        this.ore_detector_btn = new OreDetectorButton(p3x2, y+b, b3w, b3h);
        this.port_map_btn = new PortMapButton(p3x2, p3y2, b3w, b3h);
        this.live_status_btn = new LiveStatusButton(p3x2, p3y3, b3w, b3h);
        this.ore_detector = new OreDetector(p4x, y+b, p4w, b3h);
        this.port_map = new PortMap(p4x, p3y2, p4w, b3h);
        this.live_status = new LiveStatus(p4x, p3y3, p4w, b3h);
    }
    draw(gfx) {
        this.alt_gauge.draw(gfx);
        this.ore_gauge.draw(gfx);
        this.fuel_gauge.draw(gfx);
        this.scoop_btn.draw(gfx);
        this.lsi_btn.draw(gfx);
        this.fly_btn.draw(gfx);
        this.ore_detector_btn.draw(gfx);
        this.port_map_btn.draw(gfx);
        this.live_status_btn.draw(gfx);
        this.ore_detector.draw(gfx);
        this.port_map.draw(gfx);
        this.live_status.draw(gfx);
    }
}; // class Dash

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.user_acct = new Account(10000);
        const canvas = gfx.ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;
        const dash_y = h*.08;
        const dash_h = h*.25;
        const view_y = dash_y + dash_h;
        const view_h = h - view_y;
        this.ship = new Ship(1000);
        this.dash = new Dash(this.ship, 0, dash_y, w, dash_h);
        this.view = new LiveView(0, view_y, w, view_h);
        this.msg = null;
    }
    message(msg) {
        this.msg = msg;
    }
    draw() {
        const gfx = this.gfx;
        const ctx = gfx.ctx;
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        gfx.draw_rect(0, 0, ctx.canvas.width, ctx.canvas.height, config.color_sky);
        const time = now();
        this.ship.update(time);
        this.view.draw(gfx);
        this.dash.draw(gfx);
        this.draw_message(thimsg);
    }
    draw_message() {
        if (this.msg != null) return;
        ...
    }
}; // class Game

// --------------------------------------------------------------------

var _game = null;

function now() {
    return performance.now();
}
function draw_game() {
    _game.draw();
    window.requestAnimationFrame(draw_game);
}

function main() {
    const canvas = el("canvas");
    const gfx = new Graphics(canvas.getContext("2d"));
    _game = new Game(gfx);
    window.requestAnimationFrame(draw_game);
}

function el(name) {
    return document.getElementById(name);
}

function hex2(n) {
    let hex = Math.floor(n).toString(16);
    while (hex.length < 2) hex = "0"+hex;
    return hex;
}
</script>
</body>
</html>
