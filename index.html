<!doctype html>
<meta charset="UTF-8">
<html>
<head>
<title>Asteroid Miner</title>
</head>
<body onload="main()">
<canvas id="canvas" width="1" height="1" style="font-family:Arial"></canvas>
<script>

// --------------------------------------------------------------------
// Globals
var _game = null;

var config = {
    button_border          : 3,
    crit_fuel              : 2,
    deposit_screens_per    : 1,
    fuel_per_thrust        : 0.2,
    gauge_border           : 3,
    low_fuel               : 10,
    max_elev               : 1000,
    max_fuel               : 100,
    meter_per_pix          : 10,
    min_elev               : 10,
    ore_mass_max           : 1000,
    ore_mass_min           : 8,
    port_screens_per       : 5,
    ports_per_km           : 0.2,
    ship_bot_thrust        : 10,
    ship_mass              : 50,
    ship_max_cargo         : 500,
    terr_step              : 24, // pixels
    view_width_m           : 1500,
    view_xstep_m           : 50,
    ///world_diam             : 1000*1000, // 1000 km

    color_btn_active       : "10ff40",
    color_btn_inactive     : "c08010",
    color_btn_none         : "808080",
    color_btn_text         : "ffffff",
    color_dash_bg          : "669ae4",
    color_fuel             : "10d040",
    color_gauge_bg         : "e0e0e0",
    color_gauge_border     : "a098b0",
    color_gauge_text       : "000000",
    color_gauge_title      : "ffffff",
    color_gauge_low        : "d09000",
    color_gauge_crit       : "ff1010",
    color_resmap_bg        : "a8a818",
    color_terrain          : "707070",
    color_ore              : "c000c0",
    color_port             : "ff0000",
    color_sky              : "000000",
    color_ship             : "10ffff",
    color_thrust           : "ff3010",
};

// --------------------------------------------------------------------
class Color {
    constructor(hex) {
        this.hex_str = hex;
    }
    hex() {
        return this.hex_str;
    }
    jstring() {
        return "#" + this.hex_str;
    }
    get_comp(comp) {
        return parseInt(this.hex_str.substr(comp*2, 2), 16);
    }
    adj(comp, incr) {
        let val = this.get_comp(comp) + incr;
        if (val < 0) val = 0;
        if (val > 255) val = 255;
        const ci = comp*2;
        return new Color(this.hex_str.substr(0,ci) + hex2(val) + this.hex_str.substr(ci+2));
    }
    darker(mult) {
        return new Color(hex2(this.get_comp(0)*mult) + hex2(this.get_comp(1)*mult) + hex2(this.get_comp(2)*mult));
    }
    opposite() {
        return new Color(hex2(255-this.get_comp(0)) + hex2(255-this.get_comp(1)) + hex2(255-this.get_comp(2)));
    }
    contrast() {
        const bright = this.get_comp(0) + this.get_comp(1) + this.get_comp(2);
        return new Color((bright > (3*128)) ? "000000" : "ffffff");
    }
};

// --------------------------------------------------------------------
class Vector {
    constructor(x,y) {
        this.x = x;
        this.y = y;
    }
    add(v) {
        this.x += v.x;
        this.y += v.y;
    }
    mul(num) {
        return new Vector(this.x*num, this.y*num);
    }
    norm2() {
        return this.x*this.x + this.y*this.y;
    }
}; // class Vector

// --------------------------------------------------------------------
class Graphics {
    constructor(ctx) {
        this.ctx = ctx;
        const text_size = ctx.measureText("M");
        this.font_height = Math.floor(text_size.width * 1.5); // FIXME
    }
    clear(color) {
        const canvas = this.ctx.canvas;
        const w = canvas.width;
        const h = canvas.height;
        this.ctx.clearRect(0, 0, w, h);
        this.draw_rect(0, 0, w, h, color);
    }
    draw_rect(x, y, w, h, color) {
        if (color != undefined && color != null) this.ctx.fillStyle = color.jstring();
        this.ctx.fillRect(x, y, w, h);
    }
    draw_centered_rect(cx, cy, w, h, color) {
        this.draw_rect(cx - w/2, cy - h/2, w, h, color);
    }
    draw_outline(x, y, w, h, xb, yb, color) {
        this.draw_rect(x,      y,       w-xb,   yb,   color);
        this.draw_rect(x+w-xb, y,       xb,     h-yb, color);
        this.draw_rect(x+xb,   y+h-yb,  w-xb,   yb,   color);
        this.draw_rect(x,      y+yb,    xb,     h-yb, color);
    }
    draw_centered_outline(cx, cy, w, h, xb, yb, color) {
        this.draw_outline(cx - w/2, cy - h/2, w, h, xb, yb, color);
    }
    draw_outlined_rect(x, y, w, h, xb, yb, bg_color, border_color) {
        this.draw_rect(x+xb, y+yb, w-2*xb, h-2*yb, bg_color);
        this.draw_outline(x, y, w, h, xb, yb, border_color);
    }
    draw_circle(x, y, r, color) {
        this.ctx.beginPath();
        this.ctx.fillStyle = color.jstring();
        this.ctx.arc(x, y, r, 0, 2*Math.PI);
        this.ctx.fill();
    }
    draw_text(x, y, text, color) {
        this.ctx.fillStyle = color.jstring();
        this.ctx.fillText(text, x, y+this.font_height);
    }
    measure_text(text) {
        const text_size = this.ctx.measureText(text);
        return { width: text_size.width, height: this.font_height };
    }
    draw_centered_text(x, y, w, text, color) {
        const text_size = this.measure_text(text);
        const nx = x + (w - text_size.width) / 2;
        if (nx > x) x = nx;
        this.draw_text(x, y, text, color);
        return text_size;
    }
}; // class Graphics

// --------------------------------------------------------------------
class DashClock {
    constructor() {
    }
}; // class DashClock

// --------------------------------------------------------------------
class Gauge {
    constructor(x, y, w, h, title, color, max_value, low_value = -1, crit_value = -1, fetcher = null) {
        this.title = title;
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.color = color;
        this.max_value = max_value;
        this.low_value = low_value;
        this.crit_value = crit_value;
        this.fetcher = fetcher;
        this.value = 0;
    }
    set_value(value) {
        if (value < 0) value = 0;
        if (value > this.max_value) value = this.max_value;
        this.value = value;
    }
    get_value(value) {
        return this.value;
    }
    draw(gfx) {
        if (this.fetcher != null)
            this.value = this.fetcher.gauge_value();
        let title_size = gfx.draw_centered_text(this.x, this.y, this.w, this.title, config.color_gauge_title);
        const gh = this.h - title_size.height *1.5;
        const gb = config.gauge_border;
        const inh = gh - 2*gb;
        const inw = this.w - 2*gb;
        const barh = inh * this.value / this.max_value;
        const bot = this.y + this.h;
        const value_text = Math.floor(this.value).toString();
        const value_text_size = gfx.measure_text(value_text);
        gfx.draw_outlined_rect(this.x, bot-gh, this.w, gh, gb, gb, config.color_gauge_bg, config.color_sky);
        gfx.draw_rect(this.x+gb, bot-gb-barh, inw, barh, this.color);
        gfx.draw_centered_text(this.x, bot-value_text_size.height*1.5, this.w, value_text, config.color_gauge_text);
        if (this.value <= this.crit_value) {
            gfx.draw_centered_text(this.x, this.y+this.h/2-value_text_size.height/2, this.w, "LOW", config.color_gauge_low);
        } else if (this.value <= this.low_value) {
            gfx.draw_centered_text(this.x, this.y+this.h/2-value_text_size.height/2, this.w, "CRITICAL", config.color_gauge_crit);
        }
    }
}; // class Gauge

// --------------------------------------------------------------------
class FuelGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Fuel", config.color_fuel, config.max_fuel, config.low_fuel, config.crit_fuel, new ShipFuelFetcher(ship));
    }
}; // class FuelGauge

// --------------------------------------------------------------------
class OreGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Cargo", config.color_ore, ship.max_cargo, -1, -1, new ShipCargoFetcher(ship));
    }
}; // class OreGauge

// --------------------------------------------------------------------
class ElevationGauge extends Gauge {
    constructor(x, y, w, h, ship) {
        super(x, y, w, h, "Elev.", config.color_terrain, config.max_elev);
    }
}; // class ElevationGauge

// --------------------------------------------------------------------
class Button {
    constructor(state_titles, state_colors, state, x, y, w, h, click_handler, state_fetcher) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.state_titles = state_titles;
        this.state_colors = state_colors;
        this.state = state;
        this.click_handler = click_handler;
        this.state_fetcher = state_fetcher;
    }
    set_state(state) {
        this.state = state;
    }
    inside(x, y) {
        return x >= this.x && x < this.x + this.w && y >= this.y && y < this.y + this.h;
    }
    click() {
        this.click_handler.click();
    }
    draw(gfx) {
        if (this.state_fetcher != null)
            this.state = this.state_fetcher.button_state();
        let bb = config.button_border;
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, bb, bb, this.state_colors[this.state], config.color_sky);
        //let cy = this.y + this.h/2; // FIXME
        let cy = this.y + (this.h - gfx.font_height) / 2;
        gfx.draw_centered_text(this.x, cy, this.w, this.state_titles[this.state], config.color_btn_text);
    }
}; // class Button

// --------------------------------------------------------------------
class Menu {
    constructor() {
    }
}; // class Menu

// --------------------------------------------------------------------
class PortMenu {
    constructor() {
    }
}; // class PortMenu

// --------------------------------------------------------------------
class Store {
constructor() {
}
}; // class Store

// --------------------------------------------------------------------
class StoreMenu {
    constructor() {
    }
}; // class StoreMenu

// --------------------------------------------------------------------
class ScoopButton extends Button {
    constructor(x, y, w, h) {
        super(["Ore scoop: off", "Ore scoop: on", "Ore scoop: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, ScoopButton.click);
    }
    static click() {
    }
}; // class ScoopButton

// --------------------------------------------------------------------
class LSIButton extends Button {
    constructor(x, y, w, h) {
        super(["LSI: off", "LSI: on"],
            [config.color_btn_inactive, config.color_btn_active],
            0, x, y, w, h, LSIButton.click);
    }
    static click() {
    }
}; // class LSIButton

// --------------------------------------------------------------------
class FlyingButton extends Button {
    constructor(x, y, w, h, ship) {
        super(["On ground", "Flying"],
            [config.color_btn_inactive, config.color_btn_active],
            0, x, y, w, h, null, new ShipFlyingStateFetcher(ship));
    }
}; // class LSIButton

// --------------------------------------------------------------------
class OreDetectorButton extends Button {
    constructor(x, y, w, h) {
        super(["Ore detector: off", "Ore detector: on", "Ore detector: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, OreDetectorButton.click);
    }
    static click() {
    }
}; // class OreDetectorButton

// --------------------------------------------------------------------
class PortMapButton extends Button {
    constructor(x, y, w, h) {
        super(["Port map: off", "Port map: on", "Port map: none"],
            [config.color_btn_inactive, config.color_btn_active, config.color_btn_none],
            2, x, y, w, h, PortMapButton.click);
    }
    static click() {
    }
}; // class PortMapButton

// --------------------------------------------------------------------
class LiveStatusButton extends Button {
    constructor(x, y, w, h) {
        super(["Status"], [config.color_btn_none], 
            0, x, y, w, h, PortMapButton.click);
    }
    static click() {
    }
}; // class LiveStatusButton

// --------------------------------------------------------------------
class ResourceMap {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.installed = false;
        this.active = false;
    }
    install(ship) {
        this.installed = true;
    }
    activate(active) {
        this.active = active;
    }
    draw(gfx) {
        const color = this.active ? config.color_resmap_bg : this.installed ? config.color_btn_inactive : config.color_btn_none;
        gfx.draw_outlined_rect(this.x, this.y, this.w, this.h, config.gauge_border, config.gauge_border, color, config.color_sky); 
    }
}; // class ResourceMap

// --------------------------------------------------------------------
class OreDetector extends ResourceMap {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
}; // class OreDetector

// --------------------------------------------------------------------
class PortMap extends ResourceMap {
    constructor(x, y, w, h) {
        super(x, y, w, h);
    }
}; // class PortMap

// --------------------------------------------------------------------
class LiveStatus {
    constructor() {
    }
    draw(ctx) {
    }
}; // class LiveStatus

// --------------------------------------------------------------------
class Terrain {
    constructor(x, y, w, h) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.peaks = [];
    }
    extend(sxpos, expos) {
        //@@FIXME
        if (this.peaks.length == 0);
            this.peaks.push(0);
        let elev = this.peaks[this.peaks.length-1];
        while (this.peaks.length * config.terr_step < expos) {
            elev += (Math.random() * config.terr_step) - (config.terr_step/2);
            if (elev < config.min_elev) elev = config.min_elev;
            this.peaks.push(elev);
        }
    }
    get_peak(n) {
        this.extend(n-100, n+100); // FIXME
        return this.peaks[n];
    }
    index(xpos) {
        return Math.floor(xpos / config.terr_step);
    }
    elevation(xpos) {
        this.extend(xpos, xpos);
/*<<<*/
/*<<<*/ const lo = 0;
/*<<<*/
        const pi = this.index(xpos);
        let elev = this.peaks[pi];
        // FIXME interpolate
        return elev;
    }
    draw(gfx, xpos) {
        if (this.peaks.length == 0) return;
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_terrain.jstring();
        ctx.beginPath();
        const bot = this.y + this.h;
        let xlast = this.x;
        ctx.moveTo(this.x, bot);
        for (let pi = this.index(xpos); pi < this.peaks.length; ++pi) {
            ////const x = this.x + pi * config.view_xstep_m / config.meter_per_pix;
            const x = this.x + pi * config.terr_step;
            if (x >= gfx.ctx.canvas.width) break;
            const y = this.peaks[pi] / config.terr_step;
            ctx.lineTo(x, bot - y);
            xlast = x;
        }
        ctx.lineTo(xlast, bot); // drop to baseline at right
        ctx.fill();
    }
}; // class Terrain

// --------------------------------------------------------------------
class LandObjects {
    constructor(x, y, w, h, terrain, screens_per) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.terrain = terrain;
        this.screens_per = screens_per;
        this.resources = [];
    }
    place(xpos, thing) {
        const mag = 10;
        return (randu(this.screens_per * this.w * mag) < mag);
    }
    index(xpos) {
        for (let i = 0; i < this.resources.length; ++i) {
            if (this.resources[i].xpos > xpos)
                return (i == 0) ? 0 : i-1;
        }
        return this.resources.length-1;
    }
    draw(gfx, xpos) {
        if (this.resources.length == 0) return;
        for (let pi = this.index(xpos); pi < this.resources.length; ++pi) {
            ///const x = this.x + (this.resources[pi].xpos - xpos);
            const x1 = this.x;
            const x2 = this.resources[pi].xpos;
            const x = x1 + (x2 - xpos);
            if (x >= gfx.ctx.canvas.width) break;
            const y = this.y - this.terrain.elevation(this.resources[pi].xpos);
            if (y >= 0)
                this.resources[pi].draw(gfx, x, y);
        }
    }
}; // class LandObjects

// --------------------------------------------------------------------
class Ports extends LandObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.port_screens_per);
    }
    extend(sxpos, expos) {
        for (let xpos = sxpos; xpos < expos; ++xpos) {
            if (this.place(xpos))
                this.resources.push(new Port(xpos));
        }
    }
}; // class Ports

// --------------------------------------------------------------------
class OreDeposits extends LandObjects {
    constructor(x, y, w, h, terrain) {
        super(x, y, w, h, terrain, config.deposit_screens_per);
    }
    extend(sxpos, expos) {
        for (let xpos = sxpos; xpos < expos; ++xpos) {
            if (this.place(xpos))
                this.resources.push(new OreDeposit(this.ore_mass(xpos), xpos));
        }
    }
    ore_mass(xpos) {
        const M = config.ore_mass_max;
        const k = nhash(xpos) % M;
        return config.ore_mass_min + Math.floor((k*k*k) / (M*M));
    }
}; // class OreDeposits

// --------------------------------------------------------------------
class OreDeposit {
    constructor(mass, xpos) {
        this.mass = mass;
        this.xpos = xpos;
    }
    draw(gfx, x, y) {
        const r = Math.sqrt(this.mass) * .1; // FIXME
        gfx.draw_circle(x, y, r, config.color_ore);
    }
}; // class OreDeposit

// --------------------------------------------------------------------
class Billboard {
    constructor() {
    }
}; // class Billboard

// --------------------------------------------------------------------
class Port {
    constructor(xpos) {
        this.xpos = xpos;
        this.name = "Omega Station";
    }
    draw(gfx, x, y) {
        gfx.draw_rect(x-25, y-10, 50, 20, config.color_port);
        gfx.draw_text(x, y-20, this.name, config.color_port);
    }
}; // class Port

// --------------------------------------------------------------------
class LiveView {
    constructor(x, y, w, h, ship) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        this.ship = ship;
        this.terrain = new Terrain(x, y, w, h);
        this.ports = new Ports(x, y, w, h, this.terrain);
        this.deposits = new OreDeposits(x, y, w, h, this.terrain);
    }
    extend(sxpos, expos) { // this is weird
        this.terrain.extend(sxpos, expos);
        this.ports.extend(sxpos, expos);
        this.deposits.extend(sxpos, expos);
    }
    draw(gfx) {
        const xpos = this.ship.loc.x - this.w/2;
        this.extend(xpos, xpos + this.w);
        this.deposits.draw(gfx, xpos);
        this.terrain.draw(gfx, xpos);
        this.ports.draw(gfx, xpos);
        this.ship.draw(gfx, xpos);
    }
}; // class LiveView

// --------------------------------------------------------------------
class Account {
    constructor(deposit) {
        this.balance = deposit;
    }
    add_cash(amt) {
        this.balance += amt;
    }
    sell_ore(ship, mass, dollars_per_ton, acct) {
        const cargo = ship.unload_ore();
        const price = dollars_per_ton * mass;
        this.add_cash(price);
    }
}; // class Account

// --------------------------------------------------------------------
class Loan {
    constructor() {
    }
}; // class Loan

// --------------------------------------------------------------------
class MassiveObject {
    constructor(mass, xpos, ypos, time) {
        this.mass = mass;
        this.loc = new Vector(xpos, ypos);
        this.vel = new Vector(0,0);
        this.acc = new Vector(0,0);
        this.time = time;
    }
    accelerate(xforce, yforce) {
        this.acc = new Vector(xforce / this.mass, yforce / this.mass);
    }
    intersects_terrain(terrain) {
        return false; // FIXME
    }
    update(time) {
        const dt = time - this.time;
        this.loc.add(this.vel.mul(dt));
        this.vel.add(this.acc.mul(dt));
        this.time = time;
    }
}; // class MassiveObject

// --------------------------------------------------------------------
class Ship extends MassiveObject {
    constructor(xpos, ypos) {
        super(config.ship_mass, xpos, ypos, now());
        this.bot_thrust = 0;
        this.side_thrust = 0;
        this.cargo = 0;
        this.max_cargo = config.ship_max_cargo;
        this.fuel = 0;
        this.max_fuel = config.max_fuel;
        this.flying = false;
        this.inport = null;
    }
    load_ore(deposit) {
        if (deposit + this.cargo > this.max_cargo)
            deposit = this.max_cargo - this.cargo;
        this.cargo += deposit;
        return deposit;
    }
    unload_ore() {
        const cargo = this.cargo;
        this.cargo = 0;
        return cargo;
    }
    add_fuel(fuel) {
        if (fuel + this.fuel > this.max_fuel)
            fuel = this.max_fuel - this.fuel;
        this.fuel += fuel;
        return fuel;
    }
    set_bot_thrust(on) {
        if (on) this.flying = true;
        this.bot_thrust = on ? config.ship_bot_thrust : 0;
    }
    set_side_thrust(left, on) {
        if (!this.flying) return;
        this.side_thrust = !on ? 0 : left ? -config.ship_side_thrust : config.ship_side_thrust;
    }
    land() {
        this.bot_thrust = this.side_thrust = 0;
        this.flying = false;
    }
    enter_port(port) {
        this.inport = port;
    }
    start_mining() {
        ///
    }
    update(time) {
        const dt = time - this.time;
        super.update(time);
        const fuel_used = (this.bot_thrust + Math.abs(this.side_thrust)) * config.fuel_per_thrust;
        this.fuel -= fuel_used;
        if (this.fuel < 0) {
            this.fuel = 0;
            //game_over("ran out of fuel");
        }
        this.accelerate(this.bot_thrust, this.side_thrust);
    }
    draw(gfx, xpos) {
        const canvas = gfx.ctx.canvas;
        const r = canvas.width * 0.01;
        const x = this.loc.x - xpos;
        const y = canvas.height - this.loc.y;
        this.draw_body(gfx, x, y, r);
        if (this.bot_thrust > 0) this.draw_bot_thrust(gfx, x, y, r);
        if (this.side_thrust > 0) this.draw_right_thrust(gfx, x, y, r);
        if (this.side_thrust < 0) this.draw_left_thrust(gfx, x, y, r);
    }
    draw_body(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_ship.jstring();
        ctx.beginPath();
        ctx.moveTo(x, y-r);
        ctx.lineTo(x-r/2, y+r);
        ctx.lineTo(x, y+r/2);
        ctx.lineTo(x+r/2, y+r);
        ctx.fill();
    }
    draw_bot_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x+r/2, y+1.5*r);
        ctx.lineTo(x, y+3*r); // tail
        ctx.lineTo(x-r/2, y+1.5*r);
        ctx.fill();
    }
    draw_left_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x-1.5*r, y-r/2);
        ctx.lineTo(x-3*r, y); // tail
        ctx.lineTo(x-1.5*r, y+r/2);
        ctx.fill();
    }
    draw_right_thrust(gfx, x, y, r) {
        const ctx = gfx.ctx;
        ctx.fillStyle = config.color_thrust.jstring();
        ctx.beginPath();
        ctx.moveTo(x+1.5*r, y-r/2);
        ctx.lineTo(x+3*r, y); // tail
        ctx.lineTo(x+1.5*r, y+r/2);
        ctx.fill();
    }
}; // class Ship

class ShipFuelFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.fuel; }
};

class ShipCargoFetcher {
    constructor(ship) { this.ship = ship; }
    gauge_value() { return this.ship.cargo; }
};

class ShipFlyingStateFetcher {
    constructor(ship) { this.ship = ship; }
    button_state() { return this.ship.flying ? 1 : 0; }
};

// --------------------------------------------------------------------
class Dash {
    constructor(x, y, w, h, ship) {
        this.x = x;
        this.y = y;
        this.w = w;
        this.h = h;
        ///this.ship = ship;
        const b   = w * .01;
        const p1w = w * .15;
        const p2w = w * .20;
        const p3w = w * .25;
        const p4w = w - (p1w + p2w + p3w + 5*b);
        const p1x = x;
        const p2x = p1x + p1w + b;
        const p3x = p2x + p2w + b;
        const p4x = p3x + p3w + b;
        const gw = Math.floor((p2w-2*b)/ 3);
        const gh = h - 2*b;
        const b3w = (p3w-b) / 2;
        const b3h = Math.floor((h-4*b) / 3);
        const p3x2 = p3x + b3w + b;
        const p3y2 = y+b+b3h+b;
        const p3y3 = p3y2+b3h+b;
        this.elev_gauge = new ElevationGauge(p2x, y+b, gw, gh, ship);
        this.ore_gauge = new OreGauge(p2x+gw+b, y+b, gw, gh, ship);
        this.fuel_gauge = new FuelGauge(p2x+2*(gw+b), y+b, gw, gh, ship);
        this.scoop_btn = new ScoopButton(p3x, y+b, b3w, b3h);
        this.lsi_btn = new LSIButton(p3x, p3y2, b3w, b3h);
        this.fly_btn = new FlyingButton(p3x, p3y3, b3w, b3h, ship);
        this.ore_detector_btn = new OreDetectorButton(p3x2, y+b, b3w, b3h);
        this.port_map_btn = new PortMapButton(p3x2, p3y2, b3w, b3h);
        this.live_status_btn = new LiveStatusButton(p3x2, p3y3, b3w, b3h);
        this.ore_detector = new OreDetector(p4x, y+b, p4w, b3h);
        this.port_map = new PortMap(p4x, p3y2, p4w, b3h);
        this.live_status = new LiveStatus(p4x, p3y3, p4w, b3h);
    }
    click(e) {
        const x = 0; ///FIIXMEE
        const y = 0;
        if (this.scoop_btn.inside(x,y)) this.scoop_btn.click();
        if (this.lsi_btn.inside(x,y)) this.lsi_btn.click();
        //if (this.fly_btn.inside(x,y)) this.fly_btn.click();
        if (this.ore_detector_btn.inside(x,y)) this.ore_detector_btn.click();
        if (this.port_map_btn.inside(x,y)) this.port_map_btn.click();
        if (this.live_status_btn.inside(x,y)) this.live_status_btn.click();
    }
    draw(gfx) {
        gfx.draw_rect(this.x, this.y, this.w, this.h, config.color_dash_bg);
        this.elev_gauge.draw(gfx);
        this.ore_gauge.draw(gfx);
        this.fuel_gauge.draw(gfx);
        this.scoop_btn.draw(gfx);
        this.lsi_btn.draw(gfx);
        this.fly_btn.draw(gfx);
        this.ore_detector_btn.draw(gfx);
        this.port_map_btn.draw(gfx);
        this.live_status_btn.draw(gfx);
        this.ore_detector.draw(gfx);
        this.port_map.draw(gfx);
        this.live_status.draw(gfx);
    }
}; // class Dash

// --------------------------------------------------------------------
class Game {
    constructor(gfx) {
        this.gfx = gfx;
        this.user_acct = new Account(10000);
        const canvas = gfx.ctx.canvas;
        const cw = canvas.width;
        const ch = canvas.height;
        const dash_y = Math.floor(ch*.04);
        const dash_h = Math.floor(ch*.30);
        const space = Math.floor(ch*.01);
        const view_y = dash_y + dash_h + space;
        const view_h = ch - view_y;
        this.ship = new Ship(1000, config.min_elev);
this.ship.add_fuel(this.ship.max_fuel/3);
        this.dash = new Dash(0, dash_y, cw, dash_h, this.ship);
        this.view = new LiveView(0, view_y, cw, view_h, this.ship);
        this.msg = null;
    }
    run() {
        const time = now();
        const ship = this.ship;
        const was_flying = ship.flying;
        ship.update(time);
        if (ship.intersects_terrain(this.view.terrain)) {
            if (ship.vel.norm2() > config.crash_vel2) {
                game_over("crashed");
            } else {
                ship.land();
            }
        }
        this.draw();
        if (ship.flying != was_flying) {
            if (was_flying) { // landing
                const port = ports.can_land(ship.loc.x);
                if (port != null)
                    ship.enter_port(port);
                else
                    ship.start_mining();
            } else { // liftoff
                ship.enter_port(null);
            }
        }
    }
    draw() {
        this.gfx.clear(config.color_sky);
        this.view.draw(this.gfx);
        this.dash.draw(this.gfx);
        this.draw_message();
    }
    static _event_keydown(e) {
        if (_game != null) _game.event_keydown(e);
    }
    static _event_keyup(e) {
        if (_game != null) _game.event_keyup(e);
    }
    static _event_click(e) {
        if (_game != null) _game.event_click(e);
    }
    event_keydown(e) {
        this.set_thrust(e.code, true);
        //this.draw();
    }
    event_keyup(e) {
        this.set_thrust(e.code, false);
        //this.draw();
    }
    event_click(e) {
        this.dash.click(e);
    }
    set_thrust(code, on) {
        switch (code) {
        case 'ArrowDown':
            this.ship.set_bot_thrust(on);
            break;
        case 'ArrowRight':
            this.ship.set_side_thrust(false, on);
            break;
        case 'ArrowLeft':
            this.ship.set_side_thrust(true, on);
            break;
        }
    }
    message(msg) {
        this.msg = msg;
    }
    draw_message() {
        if (this.msg == null) return;
        ///`
    }
}; // class Game

// --------------------------------------------------------------------

function now() {
    return performance.now();
}

function run_game() {
    if (_game != null) _game.run();
    window.requestAnimationFrame(run_game);
}

function canvas_resize() {
    const s = 20;
    const canvas = el("canvas");
    canvas.width = window.innerWidth - s;
    canvas.height = window.innerHeight - s;
}

function main() {
    munge_config();
    canvas_resize();
    const canvas = el("canvas");
    const gfx = new Graphics(canvas.getContext("2d"));
    gfx.ctx.font = Math.floor(canvas.height*.022).toString()+"px sans-serif";
    _game = new Game(gfx);
    document.addEventListener('keyup',   Game._event_keyup);
    document.addEventListener('keydown', Game._event_keydown);
    document.addEventListener('click',   Game._event_click);
    window.addEventListener('resize', canvas_resize, false);
    run_game();
}

function munge_config() {
    for (const [key,value] of Object.entries(config)) {
        if (key.substr(0,6) == "color_")
            config[key] = new Color(config[key]);
    }
}

function el(name) {
    return document.getElementById(name);
}

function hex2(n) {
    let hex = Math.floor(n).toString(16);
    while (hex.length < 2) hex = "0"+hex;
    return hex;
}

function nhash(n) {
    let r = 0;
    for (let i = 0; i < 32; ++i) {
        const bit = n ^ (n >> 2) ^ (n >> 3) ^ (n >> 5);
        n = (n >> 1) | (bit << 15);
    }
    return Math.abs(n);
}

function randu(n) {
    return Math.floor(Math.random() * n);
}
</script>
</body>
</html>
